@ /video root:video {
  #%autostart true
  #%praxis.version 4.4.0
  .renderer OpenGL
  .width 1920
  .height 1200
  .fps 60.0
  @ ./screen video:output {
    #%graph.x 2168
    #%graph.y 432
    .device 2
    .width 1920
    .height 1200
    .full-screen true
    .always-on-top true
    .undecorated true
  }
  @ ./x-fader video:xfader {
    #%graph.x 1579
    #%graph.y 310
    .code "

    enum Mode \{Normal, Add, Difference, BitXor\};
    
    @In(0) PImage bw;
    @In(1) PImage clouds;
    @In(4) PImage colours;
    @In(5) PImage videos;
    @In(6) PImage cityBuildings;
    @In(7) PImage explosion;
    @In(8) PImage bubbles;
    @In(9) PImage experiment;
    
    @P(1) Mode mode;
    @P(2) @Type.Number(min=0, max=30, def=10) double xFadeTime;
    @P(3) @ReadOnly @Type.Number(min = 0, max = 1) Property mix;
    
    @Inject Ref<int\[\]> inIdsRef;
    
    @T(0) void reset() \{
        inIdsRef.apply(ins -> \{
           ins\[0\] = 0;
           ins\[1\] = 0;
           mix.set(0);
        \});
    \}
    
    @T(10) void toBw() \{
        mode = Mode.Normal;
        fadeTo(bw);
    \}
    
    @T(11) void toClouds() \{
        mode = Mode.Normal;
        fadeTo(clouds);
    \}
    
    @T(12) void toColours() \{
        mode = Mode.Normal;
        fadeTo(colours);
    \}
    
    @T(13) void toVideos() \{
        mode = Mode.Normal;
        fadeTo(videos);
    \}
    
    @T(14) void toCityBuildings() \{
        mode = Mode.Normal;
        fadeTo(cityBuildings);
    \}
    
    @T(15) void toExplosion() \{
        mode = Mode.Normal;
        fadeTo(explosion);
    \}
    
    @T(16) void toBubbles() \{
        mode = Mode.Normal;
        fadeTo(bubbles);
    \}
    
    @T(17) void toExperiment() \{
        mode = Mode.Normal;
        fadeTo(experiment);
    \}
    
    void fadeTo(PImage in) \{
        inIdsRef.apply(inIds -> \{
            inIds\[1\] = idByIn(in);
            log(INFO, \"From scene: \" + inIds\[0\] + \" to \" + inIds\[1\]);
            if (inIds\[0\] != inIds\[1\]) \{
                mix.set(0).to(1).in(xFadeTime).easeInOut().whenDone(mix -> \{
                    inIds\[0\] = inIds\[1\];
                    log(INFO, \"Active scene: \" + inIds\[0\] + \" \" + inIds\[1\]);
                \});
            \}
        \});
    \}
    
    @Override
    public void init() \{
        inIdsRef.init(() -> new int\[\] \{2, 2\});
        IntStream.range(0, max(ins().length, insNames().length)).forEach((int i) -> 
            attachRenderQuery(insNames()\[i\], rendering -> rendering && inActive(ins()\[i\])));
    \}
    
    @Override
    public void draw() \{
        inIdsRef.apply(inIds -> \{
            PImage in0 = inById(inIds\[0\]);
            PImage in1 = inById(inIds\[1\]);
            if (d(mix) < 0.001) \{
                copy(in0);
                release(in0);
            \} else if (d(mix) > 0.999) \{
                copy(in1);
                release(in1);
            \} else if (mode == Mode.Normal) \{
                blendMode(ADD, 1 - d(mix));
                image(in0, 0, 0);
                blendMode(ADD, d(mix));
                image(in1, 0, 0);
            \} else \{
                drawBlended(in0, in1);
            \}
        \});
    \}
    
    void drawBlended(PImage in0, PImage in1) \{
        PImage fg, bg;
        double opacity;
        if (d(mix) > 0.5) \{
            fg = in0;
            bg = in1;
            opacity = (1.0 - d(mix)) * 2;
        \} else \{
            fg = in1;
            bg = in0;
            opacity = d(mix) * 2;
        \}
        copy(bg);
        release(bg);
        switch (mode) \{
            case Difference:
                blendMode(DIFFERENCE, opacity);
                break;
            case BitXor:
                blendMode(BITXOR, opacity);
                break;
            default:
                blendMode(ADD, opacity);
                break;
        \}
        image(fg, 0, 0);
    \}
    
    PImage\[\] ins() \{
        return new PImage\[\] \{ bw, clouds, colours, videos , cityBuildings, explosion, bubbles, experiment\};
    \}
    
    String\[\] insNames() \{
        return new String\[\] \{\"bw\", \"clouds\", \"colours\", \"videos\", \"city-buildings\", \"explosion\", \"bubbles\", \"experiment\"\};
    \}

    int idByIn(PImage in) \{
        for(int i=0; i<ins().length; ++i) \{
            if(inById(i) == in) \{
                return i;
            \}
        \}
        return 0;
    \} 
     
    PImage inById(int id) \{
        return ins()\[id\];
    \}
   
    boolean inActive(PImage in) \{
        return inById(inIdsRef.get()\[0\]) == in || inById(inIdsRef.get()\[1\]) == in;
    \}
"
  }
  @ ./voronoi-generator core:custom {
    #%graph.x 410
    #%graph.y 368
    #%graph.comment set width/height
    .code "import org.kynosarges.tektosyne.geometry.*;
import java.util.concurrent.CopyOnWriteArrayList;
import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 80;
    enum Movements \{
        all, oneByOne, randomly
    \};
    
    @P(0) @OnChange(\"sendProperties\") Movements movements;
    @P(1) @Type.Number(def = 20, min = 0, max = 100, skew=0.8) @OnChange(\"sendProperties\") double movementSpeed; // percentage of screen width
    @P(2) @Type.Number(def = 1, min = 0, max = 15, skew=1.5) @OnChange(\"sendProperties\") double timeToMove;
    @P(3) @Type.Boolean @OnChange(\"sendProperties\") boolean moveToCentre;
    
    @P(10) @Type.Integer(def = 6, min = 2, max = MAX_CELLS_COUNT) @OnChange(\"onCellsCountChangedFromUI\") int cellsCount;

    @P(11) @Type.Integer(def=800) int width;
    @P(12) @Type.Integer(def=600) int height;
    
    @Out(100) Data.Out<PBytes> voronoiPipeOut;
    @Out(101) Output voronoiOut;
    @Out(102) Output propertiesOut;
    @AuxIn(101) @ReadOnly Input propertiesIn;
    
    List<Cell> cells = new ArrayList<>();
    
    // Cache of the encoded data to send
    PBytes voronoiBytes;
    
    // Last moved cell number
    int lastMoved = -1;
    
    // Current coordinates of cells centers
    @Inject Ref<List<PVector>> centresRef;
    
    // Target coordinates of cells
    @Inject Property m0x, m1x, m2x, m3x, m4x, m5x, m6x, m7x, m8x, m9x,
            m10x, m11x, m12x, m13x, m14x, m15x, m16x, m17x, m18x, m19x,
            m20x, m21x, m22x, m23x, m24x, m25x, m26x, m27x, m28x, m29x,
            m30x, m31x, m32x, m33x, m34x, m35x, m36x, m37x, m38x, m39x,
            m40x, m41x, m42x, m43x, m44x, m45x, m46x, m47x, m48x, m49x,
            m50x, m51x, m52x, m53x, m54x, m55x, m56x, m57x, m58x, m59x,
            m60x, m61x, m62x, m63x, m64x, m65x, m66x, m67x, m68x, m69x,
            m70x, m71x, m72x, m73x, m74x, m75x, m76x, m77x, m78x, m79x;
    @Inject Property m0y, m1y, m2y, m3y, m4y, m5y, m6y, m7y, m8y, m9y,
            m10y, m11y, m12y, m13y, m14y, m15y, m16y, m17y, m18y, m19y,
            m20y, m21y, m22y, m23y, m24y, m25y, m26y, m27y, m28y, m29y,
            m30y, m31y, m32y, m33y, m34y, m35y, m36y, m37y, m38y, m39y,
            m40y, m41y, m42y, m43y, m44y, m45y, m46y, m47y, m48y, m49y,
            m50y, m51y, m52y, m53y, m54y, m55y, m56y, m57y, m58y, m59y,
            m60y, m61y, m62y, m63y, m64y, m65y, m66y, m67y, m68y, m69y,
            m70y, m71y, m72y, m73y, m74y, m75y, m76y, m77y, m78y, m79y;
    
    
    // Initialisation

    @Override public void init() \{
        centresRef.init(CopyOnWriteArrayList::new);
        initialiseCells();
        updateCellsCount();
        Data.link(Data.supply(this::encodeVoronoiData), voronoiPipeOut);
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        sendProperties();
    \}
    
    void initialiseCells() \{
        Property\[\]\[\] moves = \{ 
            \{m0x, m0y\}, \{m1x, m1y\}, \{m2x, m2y\}, \{m3x, m3y\}, \{m4x, m4y\}, 
            \{m5x, m5y\}, \{m6x, m6y\}, \{m7x, m7y\}, \{m8x, m8y\}, \{m9x, m9y\},
            \{m10x, m10y\}, \{m11x, m11y\}, \{m12x, m12y\}, \{m13x, m13y\}, \{m14x, m14y\}, 
            \{m15x, m15y\}, \{m16x, m16y\}, \{m17x, m17y\}, \{m18x, m18y\}, \{m19x, m19y\},
            \{m20x, m20y\}, \{m21x, m21y\}, \{m22x, m22y\}, \{m23x, m23y\}, \{m24x, m24y\}, 
            \{m25x, m25y\}, \{m26x, m26y\}, \{m27x, m27y\}, \{m28x, m28y\}, \{m29x, m29y\},
            \{m30x, m30y\}, \{m31x, m31y\}, \{m32x, m32y\}, \{m33x, m33y\}, \{m34x, m34y\}, 
            \{m35x, m35y\}, \{m36x, m36y\}, \{m37x, m37y\}, \{m38x, m38y\}, \{m39x, m39y\},
            \{m40x, m40y\}, \{m41x, m41y\}, \{m42x, m42y\}, \{m43x, m43y\}, \{m44x, m44y\}, 
            \{m45x, m45y\}, \{m46x, m46y\}, \{m47x, m47y\}, \{m48x, m48y\}, \{m49x, m49y\},
            \{m50x, m50y\}, \{m51x, m51y\}, \{m52x, m52y\}, \{m53x, m53y\}, \{m54x, m54y\}, 
            \{m55x, m55y\}, \{m56x, m56y\}, \{m57x, m57y\}, \{m58x, m58y\}, \{m59x, m59y\},
            \{m60x, m60y\}, \{m61x, m61y\}, \{m62x, m62y\}, \{m63x, m63y\}, \{m64x, m64y\}, 
            \{m65x, m65y\}, \{m66x, m66y\}, \{m67x, m67y\}, \{m68x, m68y\}, \{m69x, m69y\},
            \{m70x, m70y\}, \{m71x, m71y\}, \{m72x, m72y\}, \{m73x, m73y\}, \{m74x, m74y\}, 
            \{m75x, m75y\}, \{m76x, m76y\}, \{m77x, m77y\}, \{m78x, m78y\}, \{m79x, m79y\}
        \};
        List<Cell> newCells = new ArrayList<>();
        for(int i=0; i<MAX_CELLS_COUNT; ++i) \{
            newCells.add(new Cell(i, moves\[i\]\[0\], moves\[i\]\[1\]));
        \}
        cells = newCells;
    \}
    
    void updateCellsCount() \{
        centresRef.apply(points -> \{
            int oldSize = points.size();
            if (oldSize != cellsCount) \{
                RectD clipRect = new RectD(0, 0, width, height);
                if (oldSize < cellsCount) \{
                    PointD\[\] newPoints = GeoUtils.randomPoints(cellsCount - oldSize, clipRect, new PointDComparatorY(0), 10);
                    points.addAll(Stream.of(newPoints).map(p -> new PVector(p.x, p.y)).collect(Collectors.toList()));
                \} else \{
                    points.subList(cellsCount, oldSize).clear();
                \}
                recalculateVoronoiRegions();

                // set coordinates of new cells if added
                for(int i = oldSize; i < points.size(); ++i) \{
                    PVector point = points.get(i);
                    cells.get(i).jumpTo(point.x, point.y);
                \}
            \}
        \});
    \}
    
    void onCellsCountChangedFromUI() \{
        updateCellsCount();
        sendProperties();
    \}

    // Main method
    
    @Override
    public void update() \{
        boolean moved = false;
        for(int i=0; i<cellsCount; ++i) \{
            PVector oldPoint = centresRef.get().get(i);
            PVector newPoint = new PVector(d(cells.get(i).moveX), d(cells.get(i).moveY));
            boolean pointMoved = abs(oldPoint.x - newPoint.x) > 1 || abs(oldPoint.y - newPoint.y) > 1;
            if(pointMoved) \{
                centresRef.get().set(i, newPoint);
                moved = true;
            \}
        \}
        if(moved) \{
            recalculateVoronoiRegions();
            voronoiBytes = encodeVoronoiData();
            voronoiOut.send(voronoiBytes);
        \}
        sendProperties();
    \}

    // Cell movement
    
    @Inject int p = 0;
    
    @T(1)
    public void moveCells() \{
        if((!moveToCentre) || 0==p++%3) \{
            moveRandomly();
        \} else \{
            moveToCentre();
        \}
    \}
    
    @T(3)
    public void moveToCentre() \{
        cells.forEach(cell -> \{
            double angle = random(2*PI);
            double dist = random(height/5, height/2);
            double nx = dist*sin(angle);
            double ny = dist*cos(angle);
            double dx = width/2;
            double dy = height/2;
            cell.startMovingTo(nx+dx, ny+dy, timeToMove);
        \});
    \}
    
    @T(2)
    public void moveRandomly() \{
        if (movements.equals(Movements.all)) \{
            cells.forEach(this::moveCell);
        \} else if (movements.equals(Movements.oneByOne)) \{
            if(lastMoved < 0 || lastMoved >= cellsCount) \{
                lastMoved = 0;
            \}
            moveCell(cells.get(lastMoved++));
        \} else if (movements.equals(Movements.randomly)) \{
            cells.stream()
                    .filter(c -> random(1) > 0.5)
                    .forEach(this::moveCell);
        \}
    \}
    
    void moveCell(Cell cell) \{
        double nx, ny;
        double deltaMove = width*movementSpeed/100;

        // ensure new coordinate is inside viewport
        do \{
            double alpha = random(PI*2);
            nx = cell.x() + cos(alpha) * deltaMove;
            ny = cell.y() + sin(alpha) * deltaMove;
            deltaMove *= 0.7; // slow down to avoid infinite loop
        \} while (nx < 0 || nx > width || ny < 0 || ny > height);
        
        cell.startMovingTo(nx, ny, timeToMove);
    \}
    
    // Cell count manipulation
    
    @T(10) void addCell() \{
        if(cellsCount < MAX_CELLS_COUNT) \{
            cellsCount += 1;
            updateCellsCount();
        \}
    \}
    
    @T(11) void removeCell() \{
        if(cellsCount > 2) \{
            cellsCount -= 1;
            updateCellsCount();
        \}
    \}
    
    // voronoi calculation
    
    void recalculateVoronoiRegions() \{
        RectD clipRect = new RectD(-1000, -1000, width+1000, height+1000);
        List<PointD> centers = centresRef.get().subList(0, cellsCount).stream()
                .map(p -> new PointD(p.x, p.y)).collect(Collectors.toList());
        VoronoiResults results = Voronoi.findAll(centers.toArray(new PointD\[0\]), clipRect);

        PointD\[\]\[\] regions = results.voronoiRegions();
        for(int i = 0; i<regions.length; ++i) \{
            cells.get(i).polygon = Arrays.asList(regions\[i\])
                    .stream()
                    .map(p -> new PVector(p.x, p.y))
                    .collect(Collectors.toList());
        \}
    \}

    // Data encoded as following: 
    // int: cellsCount
    // for each cell:
    //   int: centre.x
    //   int: centre.y
    //   int: vertices count
    //   for each vertex:
    //     int: vertex.x
    //     int: vertex.y
    PBytes encodeVoronoiData() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(cellsCount);
            for(int i=0; i<cellsCount; ++i) \{
                PVector centre = centresRef.get().get(i);
                dos.writeDouble(centre.x);
                dos.writeDouble(centre.y);
                Cell cell = cells.get(i);
                dos.writeInt(cell.polygon.size());
                cell.polygon.forEach(v -> \{
                    try \{
                        dos.writeDouble(v.x);
                        dos.writeDouble(v.y);
                    \} catch (IOException ex) \{
                        throw new RuntimeException(ex);
                    \}
                \});
            \}
            dos.flush();
            PBytes bytes = os.toBytes();
            dos.close();
            return bytes;
        \} catch (Exception ex) \{
            log(ERROR, \"Voronoi data encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    
    // Sending and receiving all properties (for using with control element)
    
    void sendProperties() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(movements.ordinal());
            dos.writeDouble(movementSpeed);
            dos.writeDouble(timeToMove);
            dos.writeInt(cellsCount);
            dos.writeInt(moveToCentre ? 1 : 0);
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                int newMovements = dis.readInt();
                if (newMovements >= 0 && newMovements < Movements.values().length) \{
                    movements = Movements.values()\[newMovements\];
                \}
                double newMovementSpeed = dis.readDouble();
                if (newMovementSpeed >= 0) \{
                    movementSpeed = newMovementSpeed;                    
                \}
                double newTimeToMove = dis.readDouble();
                if (newTimeToMove >= 0) \{
                    timeToMove = newTimeToMove;                    
                \}
                int newCellsCount = dis.readInt();
                if (newCellsCount > 2 && newCellsCount <= MAX_CELLS_COUNT) \{
                    cellsCount = newCellsCount;
                    updateCellsCount();
                \}
                int newMoveToCentre = dis.readInt();
                if (newMoveToCentre == 0 || newMoveToCentre == 1) \{
                    moveToCentre = newMoveToCentre == 1;
                \}
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    // Cell container

    class Cell \{
        final int no;
        final Property moveX;
        final Property moveY;
        List<PVector> polygon;
        
        Cell(int no, Property moveX, Property moveY) \{
            this.no = no;
            this.moveX = moveX;
            this.moveY = moveY;
        \}
        
        double x() \{
            return moveX.getDouble();
        \}
        
        double y() \{
            return moveY.getDouble();
        \}
        
        void startMovingTo(double x, double y, double timeToMove) \{
            moveX.to(x).in(timeToMove).easing(Easing.cubicOut);
            moveY.to(y).in(timeToMove).easing(Easing.cubicOut);
        \}
        
        void jumpTo(double x, double y) \{
            moveX.set(x);
            moveY.set(y);
        \}
        
        PVector centre() \{
            return centresRef.get().get(no);
        \}
        
        List<PVector> polygon() \{
            return polygon;
        \}
    \}
"
    .move-to-centre true
    .movement-speed 18
    .time-to-move 1.1044821664564684
    .cells-count 30
    .width 1920
    .height 1200
  }
  @ ./clouds core:container {
    #%graph.x 951
    #%graph.y 324
    #%praxis.version 4.4.0
    @ ./squares video:gl:p2d {
      #%graph.x 225
      #%graph.y 660
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    double rand;

    void updateUniforms() \{
        shader.set(\"resolution\", width, height);
        shader.set(\"rand\", rand);
    \}
    
    @T(1) void shuffle() \{
        rand = random(100);
    \}
    
    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "// Author @patriciogv - 2015
// Title: Mosaic

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform float rand;

float random (vec2 st) \{
    return fract(sin(dot(st.xy*rand,
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

void main() \{
    vec2 st = gl_FragCoord.xy/resolution.xy;

    st *= 10.0; // Scale the coordinate system by 10
    vec2 ipos = floor(st);  // get the integer coords
    vec2 fpos = fract(st);  // get the fractional coords

    // Assign a random value based on the integer coord
    vec3 color = vec3(random(ipos));

    // Uncomment to see the subdivided grid
    // color = vec3(fpos,0.0);

    gl_FragColor = vec4(color,1.0);
\}"
    }
    @ ./lines video:gl:p2d {
      #%graph.x 29
      #%graph.y 270
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property timer;
    double angle;

    void updateUniforms() \{
        shader.set(\"resolution\", width, height);
        shader.set(\"position\", d(timer));
        shader.set(\"angle\", angle);
    \}
    
    @T(1) void animate() \{
        timer.set(0);
        timer.to(1).in(0.5).linear();
        //timer.animator().whenDone(p -> animate());
        angle = random(-PI, PI);
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
        //animate();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

uniform vec2 resolution;
uniform vec2 mouse;
uniform float position;
uniform float angle;

float random (float seed) \{
    return fract(sin(dot(vec2(seed, 1.0),
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

float plot(vec2 st, float pct)\{
  return  smoothstep( pct-0.02, pct, st.y) -
          smoothstep( pct, pct+0.02, st.y);
\}

//  Function from IÃ±igo Quiles
//  www.iquilezles.org/www/articles/functions/functions.htm
float cubicPulse( float c, float w, float x )\{
    x = abs(x - c);
    if( x>w ) return 0.0;
    x /= w;
    return 1.0 - x*x*(3.0-2.0*x);
\}

mat2 rotate2d(float _angle)\{
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
\}

void main() \{
    if(1 == position) \{
        gl_FragColor = vec4(0.0, 0.0, 0.0,1.0);
        return;
    \}

    vec2 st = gl_FragCoord.xy/max(resolution.x, resolution.y);
    st -= vec2(0.5);
    st *= rotate2d(angle);
    st += vec2(0.5);

    // Smooth interpolation between 0.1 and 0.9
    float y = cubicPulse(0.5,0.2,(st.x+position*1.2-0.5));
    vec3 color = vec3(y);

    float pct = 0; //plot(st,y);
    color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);

    gl_FragColor = vec4(color,1.0);
\}
"
    }
    @ ./vor-clouds video:gl:p2d {
      #%graph.x 1148
      #%graph.y 110
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 3
      .edge-width 18.010318833962593
      .draw-cells true
      .just-colours false
    }
    @ ./out video:container:out {
      #%graph.x 1330
      #%graph.y 310
    }
    @ ./control core:custom {
      #%graph.x -349
      #%graph.y 425
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.oneByOne;
    final double MOVEMENT_SPEED = 40;
    final double TIME_TO_MOVE = 1;
    final int MOVE_TO_CENTRE = 0;
    final int CELLS_COUNT = 12;
    final double TRANSITION_TIME = 10;
    
    @Out(209) Output showSquares;
    @Out(210) Output squaresNoWarp;
    @Out(211) Output shuffleEnable;
    @Out(212) Output gustEnable;
    @Out(213) Output strobeEnable;
    @Out(214) Output redStrobeEnable;

    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(1)
    void justClouds() \{
        showSquares.send(false);
        shuffleEnable.send(false);
        gustEnable.send(false);
        strobeEnable.send(false);
        squaresNoWarp.send(1);
        redStrobeEnable.send(false);
        activate();
    \}
    
    @T(2)
    void gusts() \{
        showSquares.send(false);
        shuffleEnable.send(false);
        gustEnable.send(true);
        strobeEnable.send(false);
        squaresNoWarp.send(1);
        redStrobeEnable.send(false);
        activate();
    \}
    
    @T(3)
    void shuffle() \{
        showSquares.send(true);
        shuffleEnable.send(true);
        gustEnable.send(true);
        strobeEnable.send(true);
        squaresNoWarp.send(1);
        redStrobeEnable.send(false);
        activate();
    \}
    
    @T(4)
    void thunder() \{
        showSquares.send(true);
        shuffleEnable.send(true);
        gustEnable.send(true);
        strobeEnable.send(true);
        squaresNoWarp.send(0);
        redStrobeEnable.send(true);
        activate();
    \}

    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @AuxOut(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @AuxOut(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x -144
      #%graph.y 835
      .address /video/x-fader.to-clouds
    }
    @ ./properties-in core:property {
      #%graph.x -651
      #%graph.y 716
      .code "

    @In(0) @Transient Input in;

    @Out(0) Output out;
    
    @Override
    public void init() \{
        in.valuesAs(PBytes.class).link(out::send);
    \}
    
    @Override
    public void starting() \{
    \}
"
    }
    @ ./squares-shuffler core:timing:animator {
      #%graph.x -41
      #%graph.y 385
      .code "

    @Inject Property shuffler, recoiler;

    @P(3) @Type.Number(min = 0, max = 60, def = 0)
    double shuffleTime;

    @P(4) @Type.Number(min = 0, max = 60, def = 0)
    double recoilTime;
    
    @Out(1) Output shuffleOut;
    @Out(2) Output gustOut;
    @Out(3) Output strobeOut;
    
    @P(1) @Type.Integer int count;
    
    @P(5) boolean shuffleEnabled;
    @P(6) boolean gustEnabled;
    @P(7) boolean strobeEnabled;

    @T(0) void shuffle() \{
        if (!shuffler.isAnimating() && !recoiler.isAnimating()) \{
            if (shuffleEnabled) \{
                shuffler.set(0).to(count).in(shuffleTime).whenDone(val -> \{
                    val.set(0);
                    recoiler.set(0).to(count).in(recoilTime);
                \});
            \}
            if (gustEnabled) \{
                gustOut.send();
            \}
            if (strobeEnabled) \{
                strobeOut.send();
            \}
        \}
    \}
    
    int lastBlip = 0;

    @Override
    public void update() \{
        if (shuffler.isAnimating()) \{
            int v = i(shuffler.get());
            if(lastBlip != v) \{
                shuffleOut.send();
                lastBlip = v;
            \}
        \}
    \}
"
      .count 40
      .shuffle-time 0.4
      .recoil-time 0.2
      .shuffle-enabled true
      .gust-enabled true
      .strobe-enabled true
    }
    @ ./bottom-right core:custom {
      #%graph.x 1266
      #%graph.y 875
    }
    @ ./ping-control core:custom {
      #%graph.x -547
      #%graph.y 20
      .code "

    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    
    @T(10) void ping0RedIn() \{
        ping0Red.send();
    \}
    @T(11) void ping1YellowIn() \{
        ping1Yellow.send();
    \}
    @T(12) void ping2CyanIn() \{
        ping2Cyan.send();
    \}
"
    }
    @ ./strobe-0 video:gl:p2d {
      #%graph.x 763
      #%graph.y -350
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.3
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-red video:gl:p2d {
      #%graph.x 561
      #%graph.y -77
      .code "import java.awt.Color;


    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    
    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;
    
    @P(20) boolean enabled;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if(enabled) \{
            if (shader == null) \{
                shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
            \}
            shader(shader);
            shader.set(\"brightness\", d(strobeBrightness));
            shader.set(\"colour\", red, green, blue);
            rect(0, 0, width, height);
            resetShader();
        \}
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .ease 0.4
      .red 243.0
      .blue 13.600000000000001
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      .enabled true
    }
    @ ./trigger-splitter core:custom {
      #%graph.x 236
      #%graph.y -369
      .code "
    @P(0) @Type.Number(def=0) @ReadOnly Property counter;
    
    @Out(0) Output outEach;
    @Out(1) Output out1Of2;
    @Out(2) Output out2Of2;
    @Out(3) Output out1Of4;
    @Out(4) Output out2Of4;
    @Out(5) Output out3Of4;
    @Out(6) Output out4Of4;
    @Out(7) Output out1Of8;
    @Out(8) Output out2Of8;
    @Out(9) Output out3Of8;
    @Out(10) Output out4Of8;
    @Out(11) Output out5Of8;
    @Out(12) Output out6Of8;
    @Out(13) Output out7Of8;
    @Out(14) Output out8Of8;
    
    @T(0) void trigger() \{
        int count = i(counter);
        counter.set((count + 1) % 8);
        outEach.send();
        switch(count) \{
            case 0: out1Of2.send(); out1Of4.send(); out1Of8.send(); break;
            case 1: out2Of2.send(); out2Of4.send(); out2Of8.send(); break;
            case 2: out1Of2.send(); out3Of4.send(); out3Of8.send(); break;
            case 3: out2Of2.send(); out4Of4.send(); out4Of8.send(); break;
            case 4: out1Of2.send(); out1Of4.send(); out5Of8.send(); break;
            case 5: out2Of2.send(); out2Of4.send(); out6Of8.send(); break;
            case 6: out1Of2.send(); out3Of4.send(); out7Of8.send(); break;
            case 7: out2Of2.send(); out4Of4.send(); out8Of8.send(); break;
        \}
    \}
    
    @T(1) void reset() \{
        counter.set(0);
    \}
"
    }
    @ ./properties-out core:routing:send {
      #%graph.x -140
      #%graph.y 775
      .address /video/voronoi-generator.properties-in
    }
    @ ./in core:container:in {
      #%graph.x 1019
      #%graph.y 528
    }
    @ ./noise-warp video:gl:p3d {
      #%graph.x 582
      #%graph.y 403
      .code "

    @P(1) @Type.Number(min = 0, max = 1, def = 0.1)
    Property amplitude;
    @P(2) @Type.Number(min = 0, max = 1, def = 0.1)
    double speed;
    @P(3) @Type.Number(min = 0, max = 5, def = 2)
    double frequency;
    @P(100)
    Property _time;
    
    @T(0) void warp() \{
        if(!amplitude.isAnimating()) \{
            amplitude.set(1).to(0).in(1).easeIn();
        \}
    \}
    
    void updateUniforms() \{
        if (!_time.isAnimating()) \{
            _time.set(0).to(86400).in(86400);
        \}
        shader.set(\"time\", d(_time));
        shader.set(\"amplitude\", d(amplitude));
        shader.set(\"speed\", speed);
        shader.set(\"frequency\", frequency);
    \}

    
    // BOILERPLATE BELOW
    @In(0)
    PImage in;
    @P(0)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        updateUniforms();
        image(in, 0, 0);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}

"
      .fragment "
varying vec4 vertTexCoord;
uniform sampler2D texture;
uniform float time;
uniform float amplitude;
uniform float speed;
uniform float frequency;

            //
            // Description : Array and textureless GLSL 2D/3D/4D simplex
            // noise functions.
            // Author : Ian McEwan, Ashima Arts.
            // Maintainer : ijm
            // Lastmod : 20110822 (ijm)
            // License : Copyright (C) 2011 Ashima Arts. All rights reserved.
            // Distributed under the MIT License. See LICENSE file.
            // https://github.com/ashima/webgl-noise
            //

            vec3 mod289(vec3 x) \{
             return x - floor(x * (1.0 / 289.0)) * 289.0;
            \}

            vec4 mod289(vec4 x) \{
             return x - floor(x * (1.0 / 289.0)) * 289.0;
            \}

            vec4 permute(vec4 x) \{
             return mod289(((x*34.0)+1.0)*x);
            \}

            vec4 taylorInvSqrt(vec4 r)
            \{
                return 1.79284291400159 - 0.85373472095314 * r;
            \}
                                             
            float snoise(vec3 v)
            \{
                const vec2 C = vec2(1.0/6.0, 1.0/3.0) ;
                const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                
                // First corner
                vec3 i = floor(v + dot(v, C.yyy) );
                vec3 x0 = v - i + dot(i, C.xxx) ;
                
                // Other corners
                vec3 g = step(x0.yzx, x0.xyz);
                vec3 l = 1.0 - g;
                vec3 i1 = min( g.xyz, l.zxy );
                vec3 i2 = max( g.xyz, l.zxy );
                
                // x0 = x0 - 0.0 + 0.0 * C.xxx;
                // x1 = x0 - i1 + 1.0 * C.xxx;
                // x2 = x0 - i2 + 2.0 * C.xxx;
                // x3 = x0 - 1.0 + 3.0 * C.xxx;
                vec3 x1 = x0 - i1 + C.xxx;
                vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
                vec3 x3 = x0 - D.yyy; // -1.0+3.0*C.x = -0.5 = -D.y
                
                // Permutations
                i = mod289(i);
                vec4 p = permute( permute( permute(
                                                   i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                                          + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                                 + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
                
                // Gradients: 7x7 points over a square, mapped onto an octahedron.
                // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)
                float n_ = 0.142857142857; // 1.0/7.0
                vec3 ns = n_ * D.wyz - D.xzx;
                
                vec4 j = p - 49.0 * floor(p * ns.z * ns.z); // mod(p,7*7)
                
                vec4 x_ = floor(j * ns.z);
                vec4 y_ = floor(j - 7.0 * x_ ); // mod(j,N)
                
                vec4 x = x_ *ns.x + ns.yyyy;
                vec4 y = y_ *ns.x + ns.yyyy;
                vec4 h = 1.0 - abs(x) - abs(y);
                
                vec4 b0 = vec4( x.xy, y.xy );
                vec4 b1 = vec4( x.zw, y.zw );
                
                //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;
                //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;
                vec4 s0 = floor(b0)*2.0 + 1.0;
                vec4 s1 = floor(b1)*2.0 + 1.0;
                vec4 sh = -step(h, vec4(0.0));
                
                vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
                vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
                
                vec3 p0 = vec3(a0.xy,h.x);
                vec3 p1 = vec3(a0.zw,h.y);
                vec3 p2 = vec3(a1.xy,h.z);
                vec3 p3 = vec3(a1.zw,h.w);
                
                //Normalise gradients
                vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
                p0 *= norm.x;
                p1 *= norm.y;
                p2 *= norm.z;
                p3 *= norm.w;
                
                // Mix final noise value
                vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                m = m * m;
                return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                             dot(p2,x2), dot(p3,x3) ) );
            \}
            // end of noise functions
                                         
            void main()
            \{
                vec2 texCoords = vertTexCoord.st + vec2(
                    amplitude * (snoise(vec3(frequency * vertTexCoord.st.s, frequency * vertTexCoord.st.t, speed * time))),
                    amplitude * (snoise(vec3(frequency * vertTexCoord.st.s + 17.0, frequency * vertTexCoord.st.t, speed * time)))
                );
                vec2 pos = 0.5 - vertTexCoord.st;  
                gl_FragColor = texture2D(texture, texCoords); 
            \}"
      .amplitude 0.0
    }
    @ ./xfader video:xfader {
      #%graph.x 836
      #%graph.y 500
      .mix 0.01485148514851485
    }
    @ ./squares-fader video:xfader {
      #%graph.x 400
      #%graph.y 675
      .code "

    @In(1) PImage in;
    
    @P(1) @OnChange(\"fadeInOut\")
    boolean enabled;
    
    @P(2) @Type.Number(min=0, max=5, def=2)
    double fadeTime;
    
    @Inject Property mix;
    
    void fadeInOut() \{
        mix.to(enabled ? 1 : 0).in(enabled ? fadeTime : 0).easeIn();
    \}
    
    @Override
    public void draw() \{
        if (d(mix) > 0.999) \{
            copy(in);
            release(in);
        \} else if (d(mix) > 0.001) \{
            blendMode(ADD, d(mix));
            image(in, 0, 0);
        \}
    \}
    
"
      .enabled true
    }
    @ ./warping-backup video:gl:p2d {
      #%graph.x 544
      #%graph.y 170
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    @Inject Property shift;
    
    @P(1) @Type.Number(min=0, max=10, def=2) double gustTime;
    
    PShader shader;
    
    void updateUniforms() \{
        shader.set(\"time\", (millis()+i(shift))/2);
        shader.set(\"resolution\", width, height);
    \}
    
    @T(0) void gust() \{
//        if(!shift.isAnimating()) \{
            shift.to(d(shift)+10000).in(gustTime).easing(Easing.cubicOut);
//        \}
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "// Author @patriciogv - 2015
// http://patriciogonzalezvivo.com

#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;
uniform vec2 redCell = \{-1.0, -1.0\};

float random (in vec2 _st) \{
    return fract(sin(dot(_st.xy,
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

// Based on Morgan McGuire @morgan3d
// https://www.shadertoy.com/view/4dS3Wd
float noise (in vec2 _st) \{
    vec2 i = floor(_st);
    vec2 f = fract(_st);

    // Four corners in 2D of a tile
    float a = random(i);
    float b = random(i + vec2(1.0, 0.0));
    float c = random(i + vec2(0.0, 1.0));
    float d = random(i + vec2(1.0, 1.0));

    vec2 u = f * f * (3.0 - 2.0 * f);

    return mix(a, b, u.x) +
            (c - a)* u.y * (1.0 - u.x) +
            (d - b) * u.x * u.y;
\}

#define NUM_OCTAVES 5

float fbm ( in vec2 _st) \{
    float v = 0.0;
    float a = 0.5;
    vec2 shift = vec2(100.0);
    // Rotate to reduce axial bias
    mat2 rot = mat2(cos(0.5), sin(0.5),
                    -sin(0.5), cos(0.50));
    for (int i = 0; i < NUM_OCTAVES; ++i) \{
        v += a * noise(_st);
        _st = rot * _st * 2.0 + shift;
        a *= 0.5;
    \}
    return v;
\}

void main() \{
    float ktime = pow(time, 0.6); // change power to regulate speed
    vec2 st = gl_FragCoord.xy/resolution.xy*3.;
    st.x += pow(time, 0.4);
//     st += st * abs(sin(time*0.1)*3.0);
    vec3 color = vec3(0.0);

    vec2 q = vec2(0.);
    q.x = fbm( st + .0*ktime);
    q.y = fbm( st + vec2(1.0));

    vec2 r = vec2(0.);
    r.x = fbm( st + 1.0*q + vec2(1.7,9.2)+ 0.15*ktime );
    r.y = fbm( st + 1.0*q + vec2(8.3,2.8)+ 0.126*ktime);

    float f = fbm(st+r);


    color = mix(vec3(0.101961,0.619608,0.666667),
                vec3(0.666667,0.666667,0.498039),
                clamp((f*f)*4.0,0.0,1.0));

    color = mix(color,
                vec3(0.0,0,0.164706),
                clamp(length(q),0.0,1.0));

    color = mix(color,
                vec3(0.666667,1,1),
                clamp(length(r.x),0.0,1.0));

    gl_FragColor = vec4((f*f*f+.6*f*f+.5*f)*color,1.);
\}
"
    }
    ~ ./lines!out ./vor-clouds!in-edges
    ~ ./vor-clouds!out ./out!in
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./properties-in!out ./control!properties-in
    ~ ./strobe-0!out ./vor-clouds!in-0
    ~ ./strobe-0!out ./vor-clouds!in-1
    ~ ./strobe-0!out ./vor-clouds!in-2
    ~ ./squares-shuffler!shuffle-out ./squares!shuffle
    ~ ./trigger-splitter!out-2-of-4 ./strobe-0!strobe
    ~ ./trigger-splitter!out-3-of-4 ./strobe-0!strobe
    ~ ./trigger-splitter!out-4-of-4 ./strobe-0!strobe
    ~ ./trigger-splitter!out-1-of-4 ./strobe-red!strobe
    ~ ./strobe-red!out ./vor-clouds!in-0
    ~ ./strobe-red!out ./vor-clouds!in-1
    ~ ./strobe-red!out ./vor-clouds!in-2
    ~ ./ping-control!ping-2-cyan ./lines!animate
    ~ ./ping-control!ping-1-yellow ./squares-shuffler!shuffle
    ~ ./control!properties-out ./properties-out!in
    ~ ./in!out ./vor-clouds!voronoi-in
    ~ ./trigger-splitter!out-1-of-4 ./noise-warp!warp
    ~ ./control!gust-enable ./squares-shuffler!gust-enabled
    ~ ./control!strobe-enable ./squares-shuffler!strobe-enabled
    ~ ./squares-shuffler!strobe-out ./trigger-splitter!trigger
    ~ ./control!shuffle-enable ./squares-shuffler!shuffle-enabled
    ~ ./noise-warp!out ./xfader!in-1
    ~ ./xfader!out ./vor-clouds!in-2
    ~ ./control!squares-no-warp ./xfader!mix
    ~ ./control!red-strobe-enable ./strobe-red!enabled
    ~ ./squares-fader!out ./xfader!in-2
    ~ ./squares-fader!out ./noise-warp!in
    ~ ./squares!out ./squares-fader!in
    ~ ./control!show-squares ./squares-fader!enabled
    ~ ./squares-shuffler!gust-out ./warping-backup!gust
    ~ ./warping-backup!out ./vor-clouds!in-0
    ~ ./warping-backup!out ./vor-clouds!in-1
    ~ ./warping-backup!out ./noise-warp!in
  }
  @ ./bw core:container {
    #%graph.x 954
    #%graph.y 235
    #%praxis.version 4.1.1
    @ ./vor-bw video:gl:p2d {
      #%graph.x 699
      #%graph.y -78
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 5
      .edge-width 1
      .draw-cells true
      .just-colours false
    }
    @ ./out video:container:out {
      #%graph.x 952
      #%graph.y 122
    }
    @ ./in core:container:in {
      #%graph.x 472
      #%graph.y 322
    }
    @ ./properties-send core:routing:send {
      #%graph.x -66
      #%graph.y 640
      .address /video/voronoi-generator.properties-in
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x -66
      #%graph.y 690
      .address /video/x-fader.to-bw
    }
    @ ./control core:custom {
      #%graph.x -438
      #%graph.y -178
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    @Out(32) Output blackCells0;
    @Out(33) Output whiteCells0;
    @Out(34) Output blackCells1;
    @Out(35) Output whiteCells1;
    @Out(40) Output blackEdges;
    @Out(41) Output whiteEdges;
    
    @Out(50) Output strobeMain;
    @Out(51) Output strobeHeavy;
    @Out(52) Output strobeHeavyNow;
    
    final Movements MOVEMENTS = Movements.randomly;
    final double MOVEMENT_SPEED = 10;
    final double TIME_TO_MOVE = 0.4;
    final int MOVE_TO_CENTRE = 0;
    final int CELLS_COUNT = 40;
    final double TRANSITION_TIME = 10;


    void activate(double movementSpeed, double timeToMove, int cellsCount) \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        targetMovements = MOVEMENTS;
        xFade.send();
    \}
    
    @T(30) void fastEdges() \{
        activate(MOVEMENT_SPEED, TIME_TO_MOVE, CELLS_COUNT);
        startUpdating();
        
        whiteEdges.send();
        blackCells0.send();
        blackCells1.send();
        strobeHeavy.send(false);
        strobeMain.send(true);
    \}

    @T(31) void whiteCells() \{
        activate(MOVEMENT_SPEED, TIME_TO_MOVE, CELLS_COUNT);
        startUpdating();

        blackCells0.send();
        strobeMain.send(true);
        strobeHeavy.send(false);
        whiteCells1.send();
        blackEdges.send();
    \}

    @T(32) void strobeCells() \{
        activate(30, TIME_TO_MOVE, 20);
        targetCellsCount = 20;
        targetMovementSpeed = 30;
        startUpdating();
        
        blackEdges.send();
        blackCells0.send();
        blackCells1.send();
        strobeMain.send(true);
        strobeHeavy.send(false);
    \}

    @T(33) void fluidEdges() \{
        activate(30, 4, CELLS_COUNT);
        targetMovements = Movements.all;
        startUpdating();

        blackEdges.send();
        blackCells0.send();
        blackCells1.send();
        strobeMain.send(true);
        strobeHeavyNow.send();
        whiteEdges.send();
        strobeHeavy.send(false);
    \}
    
    
////////////////////////////////////////////////////////
//// Common code below (v.2.0) 
    @P(0)
    @OnChange(\"startUpdating\")
    Movements targetMovements = Movements.randomly;
    @P(1) @Type.Number(min=0, max=100, def=10)
    @OnChange(\"startUpdating\")
    double targetMovementSpeed;
    @P(2) @Type.Number(min=0, max=10, def=0.4, skew=3)
    @OnChange(\"startUpdating\")
    double targetTimeToMove = 0.4;
    @P(3) @Type.Integer(min=0, max=1, def=0)
    @OnChange(\"startUpdating\")
    int targetMoveToCentre;
    @P(4) @Type.Integer(min=0, max=80, def=40)
    @OnChange(\"startUpdating\")
    int targetCellsCount;
    @P(5) @Type.Number(min=0, max=20, def=8)
    double transitionTime = 10;
    
    Movements currentMovements;
    double currentMovementSpeed;
    double currentTimeToMove;
    int currentCcellsCount;
    int currentMoveToCentre;

    @Inject
    Movements newMovements;
    @Inject
    Property newMovementSpeed;
    @Inject
    Property newTimeToMove;
    @Inject
    Property newCellsCount;
    @Inject
    Property newMoveToCentre;
    
    @P(50) @ReadOnly
    Property transition;
    
    @AuxOut(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @AuxOut(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = targetMovements;
        newMovementSpeed.set(targetMovementSpeed);
        newTimeToMove.set(targetTimeToMove);
        newMoveToCentre.set(targetMoveToCentre);
        newCellsCount.set(targetCellsCount);
        transition.set(0);
    \}
    
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < transitionTime/2) \{
                newMovements = targetMovements;
                newMoveToCentre.set(targetMoveToCentre);
            \}
            send();
        \}
    \}
    
    void startUpdating() \{
        xFade.send();
        transition.set(0).to(100).in(transitionTime);
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
      .target-movements randomly
      .target-movement-speed 30.0
      .target-cells-count 20
      .transition-time 6.0
    }
    @ ./properties-in core:property {
      #%graph.x -725
      #%graph.y 278
      .code "

    @In(0) @Transient Input in;

    @Out(0) Output out;
    
    @Override
    public void init() \{
        in.valuesAs(PBytes.class).link(out::send);
    \}
    
    @Override
    public void starting() \{
    \}
"
    }
    @ ./edges video:gl:p2d {
      #%graph.x 229
      #%graph.y 197
      .code "

    @P(0) @Type.Number(min=0, max=255) Property color;
    
    @T(10) void black() \{
        color.set(0);
    \}
    
    @T(11) void white() \{
        color.set(255);
    \}
    
    @Override
    public void setup() \{
    \}

    @Override
    public void draw() \{
        fill(d(color));
        rect(0, 0, width, height);
    \}
"
    }
    @ ./cells-0 video:gl:p2d {
      #%graph.x 227
      #%graph.y -100
      .code "

    @P(0) @Type.Number(min=0, max=255) Property color;
    
    @T(10) void black() \{
        color.set(0);
    \}
    
    @T(11) void white() \{
        color.set(255);
    \}
    
    @Override
    public void setup() \{
    \}

    @Override
    public void draw() \{
        fill(d(color));
        rect(0, 0, width, height);
    \}
"
    }
    @ ./cells-1 video:gl:p2d {
      #%graph.x 227
      #%graph.y 47
      .code "

    @P(0) @Type.Number(min=0, max=255) Property color;
    
    @T(10) void black() \{
        color.set(0);
    \}
    
    @T(11) void white() \{
        color.set(255);
    \}
    
    @Override
    public void setup() \{
    \}

    @Override
    public void draw() \{
        fill(d(color));
        rect(0, 0, width, height);
    \}
"
      .color 255.0
    }
    @ ./strobes core:container {
      #%graph.x 152
      #%graph.y -604
      #%praxis.version 4.1.1
      @ ./strobe-0 video:gl:p2d {
        #%graph.x 92
        #%graph.y -3
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-0 video:container:out {
        #%graph.x 1301
        #%graph.y -3
      }
      @ ./strobe-1 video:gl:p2d {
        #%graph.x 232
        #%graph.y 47
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-1 video:container:out {
        #%graph.x 1301
        #%graph.y 47
      }
      @ ./strobe-2 video:gl:p2d {
        #%graph.x 372
        #%graph.y 97
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-2 video:container:out {
        #%graph.x 1301
        #%graph.y 97
      }
      @ ./strobe-3 video:gl:p2d {
        #%graph.x 512
        #%graph.y 147
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-3 video:container:out {
        #%graph.x 1301
        #%graph.y 147
      }
      @ ./strobe-4 video:gl:p2d {
        #%graph.x 652
        #%graph.y 197
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-4 video:container:out {
        #%graph.x 1301
        #%graph.y 197
      }
      @ ./strobe-5 video:gl:p2d {
        #%graph.x 792
        #%graph.y 247
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-5 video:container:out {
        #%graph.x 1301
        #%graph.y 247
      }
      @ ./strobe-6 video:gl:p2d {
        #%graph.x 932
        #%graph.y 297
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease .2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-6 video:container:out {
        #%graph.x 1301
        #%graph.y 297
      }
      @ ./strobe-7 video:gl:p2d {
        #%graph.x 1072
        #%graph.y 347
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-7 video:container:out {
        #%graph.x 1301
        #%graph.y 347
      }
      @ ./in-0 core:container:in {
        #%graph.x -134
        #%graph.y -3
      }
      @ ./in-1 core:container:in {
        #%graph.x -134
        #%graph.y 47
      }
      @ ./in-2 core:container:in {
        #%graph.x -134
        #%graph.y 97
      }
      @ ./in-3 core:container:in {
        #%graph.x -134
        #%graph.y 147
      }
      @ ./in-4 core:container:in {
        #%graph.x -134
        #%graph.y 197
      }
      @ ./in-5 core:container:in {
        #%graph.x -134
        #%graph.y 247
      }
      @ ./in-6 core:container:in {
        #%graph.x -134
        #%graph.y 297
      }
      @ ./in-7 core:container:in {
        #%graph.x -134
        #%graph.y 347
      }
      ~ ./strobe-0!out ./out-0!in
      ~ ./strobe-1!out ./out-1!in
      ~ ./strobe-2!out ./out-2!in
      ~ ./strobe-3!out ./out-3!in
      ~ ./strobe-4!out ./out-4!in
      ~ ./strobe-5!out ./out-5!in
      ~ ./strobe-6!out ./out-6!in
      ~ ./strobe-7!out ./out-7!in
      ~ ./in-0!out ./strobe-0!strobe
      ~ ./in-1!out ./strobe-1!strobe
      ~ ./in-2!out ./strobe-2!strobe
      ~ ./in-3!out ./strobe-3!strobe
      ~ ./in-4!out ./strobe-4!strobe
      ~ ./in-5!out ./strobe-5!strobe
      ~ ./in-6!out ./strobe-6!strobe
      ~ ./in-7!out ./strobe-7!strobe
    }
    @ ./strobe-control core:timing:timer {
      #%graph.x -66
      #%graph.y -629
      .code "import org.praxislive.video.pgl.code.userapi.PImage;


    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(4) Output out4;
    @Out(5) Output out5;
    @Out(6) Output out6;
    @Out(7) Output out7;
    @Inject Property four;
    @P(10) boolean enabled;
    @P(11) boolean heavyEnabled;
    
    void send(Output out) \{
        if(enabled) \{
            out.send();
        \}
    \}
    
    @T(0) public void strobe0() \{ send(out0); \}
    @T(1) public void strobe1() \{ send(out1); \}
    @T(2) public void strobe2() \{ send(out2); \}
    @T(3) public void strobe3() \{ send(out3); \}
    @T(4) public void strobe4() \{ send(out4); \}
    @T(5) public void strobe5() \{ send(out5); \}
    @T(6) public void strobe6() \{ send(out6); \}
    @T(7) public void strobe7() \{ send(out7); \}
    @T(8) public void firstFour() \{
        if(heavyEnabled) \{
            final double delay = 0.05;
            four.set(0).to(1).in(delay).whenDone(one -> \{
                send(out0);
                one.set(0).to(1).in(delay).whenDone(two -> \{
                    send(out1);
                    two.set(0).to(1).in(delay).whenDone(three -> \{
                        send(out2);
                        three.set(0).to(1).in(delay).whenDone(four -> \{
                            send(out3);
                        \});
                    \});
                \});
            \});
        \}
    \}
    
"
      .enabled true
    }
    @ ./trigger-splitter core:custom {
      #%graph.x -374
      #%graph.y -619
      #%graph.minimized true
      .code "

    @P(0)
    @Type.Number(def = 0)
    @ReadOnly
    Property counter;

    @Out(0)
    Output outEach;
    @Out(1)
    Output out1Of2;
    @Out(2)
    Output out2Of2;
    @Out(3)
    Output out1Of4;
    @Out(4)
    Output out2Of4;
    @Out(5)
    Output out3Of4;
    @Out(6)
    Output out4Of4;
    @Out(7)
    Output out1Of8;
    @Out(8)
    Output out2Of8;
    @Out(9)
    Output out3Of8;
    @Out(10)
    Output out4Of8;
    @Out(11)
    Output out5Of8;
    @Out(12)
    Output out6Of8;
    @Out(13)
    Output out7Of8;
    @Out(14)
    Output out8Of8;

    @T(0)
    void trigger() \{
        int count = i(counter);
        counter.set((count + 1) % 8);
        outEach.send();
        switch (count) \{
            case 0:
                out1Of2.send();
                out1Of4.send();
                out1Of8.send();
                break;
            case 1:
                out2Of2.send();
                out2Of4.send();
                out2Of8.send();
                break;
            case 2:
                out1Of2.send();
                out3Of4.send();
                out3Of8.send();
                break;
            case 3:
                out2Of2.send();
                out4Of4.send();
                out4Of8.send();
                break;
            case 4:
                out1Of2.send();
                out1Of4.send();
                out5Of8.send();
                break;
            case 5:
                out2Of2.send();
                out2Of4.send();
                out6Of8.send();
                break;
            case 6:
                out1Of2.send();
                out3Of4.send();
                out7Of8.send();
                break;
            case 7:
                out2Of2.send();
                out4Of4.send();
                out8Of8.send();
                break;
        \}
    \}

    @T(1)
    void reset() \{
        counter.set(0);
    \}
"
    }
    @ ./ping-control core:custom {
      #%graph.x -626
      #%graph.y -604
      .code "

    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    
    @T(10) void ping0RedIn() \{
        ping0Red.send();
    \}
    @T(11) void ping1YellowIn() \{
        ping1Yellow.send();
    \}
    @T(12) void ping2CyanIn() \{
        ping2Cyan.send();
    \}
"
    }
    ~ ./vor-bw!out ./out!in
    ~ ./in!out ./vor-bw!voronoi-in
    ~ ./control!properties-out ./properties-send!in
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./properties-in!out ./control!properties-in
    ~ ./edges!out ./vor-bw!in-edges
    ~ ./control!white-edges ./edges!white
    ~ ./cells-0!out ./vor-bw!in-0
    ~ ./cells-0!out ./vor-bw!in-1
    ~ ./cells-0!out ./vor-bw!in-2
    ~ ./cells-0!out ./vor-bw!in-3
    ~ ./cells-1!out ./vor-bw!in-4
    ~ ./control!black-edges ./edges!black
    ~ ./control!white-cells-1 ./cells-1!white
    ~ ./control!black-cells-1 ./cells-1!black
    ~ ./control!white-cells-0 ./cells-0!white
    ~ ./control!black-cells-0 ./cells-0!black
    ~ ./strobe-control!out-0 ./strobes!in-0
    ~ ./strobe-control!out-1 ./strobes!in-1
    ~ ./strobe-control!out-2 ./strobes!in-2
    ~ ./strobe-control!out-3 ./strobes!in-3
    ~ ./strobe-control!out-4 ./strobes!in-4
    ~ ./strobe-control!out-5 ./strobes!in-5
    ~ ./strobe-control!out-6 ./strobes!in-6
    ~ ./strobe-control!out-7 ./strobes!in-7
    ~ ./strobes!out-0 ./vor-bw!in-0
    ~ ./strobes!out-1 ./vor-bw!in-1
    ~ ./strobes!out-7 ./vor-bw!in-edges
    ~ ./strobes!out-2 ./vor-bw!in-2
    ~ ./strobes!out-3 ./vor-bw!in-3
    ~ ./control!strobe-main ./strobe-control!enabled
    ~ ./control!strobe-heavy ./strobe-control!heavy-enabled
    ~ ./ping-control!ping-1-yellow ./strobe-control!strobe-1
    ~ ./ping-control!ping-2-cyan ./strobe-control!strobe-2
    ~ ./ping-control!ping-2-cyan ./strobe-control!first-four
    ~ ./control!strobe-heavy-now ./strobe-control!first-four
    ~ ./ping-control!ping-0-red ./trigger-splitter!trigger
    ~ ./trigger-splitter!out-1-of-2 ./strobe-control!strobe-0
  }
  @ ./bw-control core:routing:send {
    #%graph.x 660
    #%graph.y 853
    .address /video/bw/properties-in.in
  }
  @ ./clouds-control core:routing:send {
    #%graph.x 660
    #%graph.y 903
    .address /video/clouds/properties-in.in
  }
  @ ./ping-control core:custom {
    #%graph.x 105
    #%graph.y 95
    .code "
    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @AuxOut(23) Output pingTap;
    @AuxOut(24) Output pingOsc;
    
    @P(30) boolean fftEnabled;
    @P(33) boolean tapEnabled;
    @P(34) boolean oscEnabled;
    
    @T(10) void ping0RedIn() \{
        if(fftEnabled) \{
            ping0Red.send();
        \}
    \}
    @T(11) void ping1YellowIn() \{
        if(fftEnabled) \{
            ping1Yellow.send();
        \}
    \}
    @T(12) void ping2CyanIn() \{
        if(fftEnabled) \{
            ping2Cyan.send();
        \}
    \}
    @T(13) void pingTapIn() \{
        if(tapEnabled) \{
            pingTap.send();
        \}
    \}
    @T(14) void pingOscIn() \{
        if(oscEnabled) \{
            pingOsc.send();
        \}
    \}
    @T(20) void enableAll() \{
        fftEnabled = tapEnabled = oscEnabled = true;
    \}
    @T(21) void disableAll() \{
        fftEnabled = tapEnabled = oscEnabled = false;
    \}
    
    @Override
    public void init() \{

    \}

    
    @Override
    public void update() \{

    \}
    
"
    .fft-enabled true
    .tap-enabled true
    .osc-enabled true
  }
  @ ./colours core:container {
    #%graph.x 951
    #%graph.y 420
    #%praxis.version 4.4.0
    @ ./vor-colours video:gl:p2d {
      #%graph.x 1488
      #%graph.y 199
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 7
      .edge-width 8
      .draw-cells true
      .just-colours false
    }
    @ ./control core:custom {
      #%graph.x 184
      #%graph.y 470
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.randomly;
    final double MOVEMENT_SPEED = 28;
    final double TIME_TO_MOVE = 1;
    final int MOVE_TO_CENTRE = 1;
    final int CELLS_COUNT = 36;
    final double TRANSITION_TIME = 8;
    
    @Out(10)
    Output redAndBlack;
    @Out(11)
    Output grey;
    @Out(12)
    Output colours;
    @Out(15)
    Output trueStrobeFalseShuffle;
    
    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(1)
    void grey() \{
        activate();
        grey.send();
        trueStrobeFalseShuffle.send(true);
    \}
    
    @T(2)
    void colours() \{
        activate();
        colours.send();
        trueStrobeFalseShuffle.send(false);
    \}
    
    @T(3)
    void redAndBlack() \{
        activate();
        redAndBlack.send();
        trueStrobeFalseShuffle.send(true);
    \}
    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @Out(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @Out(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x 413
      #%graph.y 820
      .address /video/x-fader.to-colours
    }
    @ ./properties-in core:property {
      #%graph.x -34
      #%graph.y 595
      .code "

    @In(0) @Transient Input in;

    @Out(0) Output out;
    
    @Override
    public void init() \{
        in.valuesAs(PBytes.class).link(out::send);
    \}
    
    @Override
    public void starting() \{
    \}
"
    }
    @ ./ping-control core:custom {
      #%graph.x 184
      #%graph.y 6
      .code "

    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    
    @T(10) void ping0RedIn() \{
        ping0Red.send();
    \}
    @T(11) void ping1YellowIn() \{
        ping1Yellow.send();
    \}
    @T(12) void ping2CyanIn() \{
        ping2Cyan.send();
    \}
"
    }
    @ ./properties-out core:routing:send {
      #%graph.x 471
      #%graph.y 731
      .address /video/voronoi-generator.properties-in
    }
    @ ./strobes core:container {
      #%graph.x 1273
      #%graph.y 233
      #%praxis.version 4.1.1
      #%graph.minimized true
      @ ./strobe-0 video:gl:p2d {
        #%graph.x 92
        #%graph.y -3
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-0 video:container:out {
        #%graph.x 1301
        #%graph.y -3
      }
      @ ./strobe-1 video:gl:p2d {
        #%graph.x 232
        #%graph.y 47
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-1 video:container:out {
        #%graph.x 1301
        #%graph.y 47
      }
      @ ./strobe-2 video:gl:p2d {
        #%graph.x 372
        #%graph.y 97
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-2 video:container:out {
        #%graph.x 1301
        #%graph.y 97
      }
      @ ./strobe-3 video:gl:p2d {
        #%graph.x 512
        #%graph.y 147
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-3 video:container:out {
        #%graph.x 1301
        #%graph.y 147
      }
      @ ./strobe-7 video:gl:p2d {
        #%graph.x 1072
        #%graph.y 347
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-7 video:container:out {
        #%graph.x 1301
        #%graph.y 347
      }
      @ ./in-0 core:container:in {
        #%graph.x -134
        #%graph.y -3
      }
      @ ./in-1 core:container:in {
        #%graph.x -134
        #%graph.y 47
      }
      @ ./in-2 core:container:in {
        #%graph.x -134
        #%graph.y 97
      }
      @ ./in-3 core:container:in {
        #%graph.x -134
        #%graph.y 147
      }
      @ ./in-7 core:container:in {
        #%graph.x -134
        #%graph.y 347
      }
      ~ ./strobe-0!out ./out-0!in
      ~ ./strobe-1!out ./out-1!in
      ~ ./strobe-2!out ./out-2!in
      ~ ./strobe-3!out ./out-3!in
      ~ ./strobe-7!out ./out-7!in
      ~ ./in-0!out ./strobe-0!strobe
      ~ ./in-1!out ./strobe-1!strobe
      ~ ./in-2!out ./strobe-2!strobe
      ~ ./in-3!out ./strobe-3!strobe
      ~ ./in-7!out ./strobe-7!strobe
    }
    @ ./strobe-control core:timing:timer {
      #%graph.x 734
      #%graph.y 6
      .code "import org.praxislive.video.pgl.code.userapi.PImage;


    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(7) Output edges7;
    
    @P(1) boolean enabledCells;
    @P(2) boolean enabledEdges;
    
    @T(0) public void strobe0() \{ 
        if(enabledCells) \{
            out0.send();
        \}
    \}
    
    @T(1)
    public void strobe1() \{
        if(enabledCells) \{
            out1.send();
        \}
    \}

    @T(2)
    public void strobe2() \{
        if(enabledCells) \{
            out2.send();
        \}
    \}

    @T(3)
    public void strobe3() \{
        if(enabledCells) \{
            out3.send();
        \}
    \}

    @T(7)
    public void strobeEdges() \{
        if(enabledEdges) \{
            edges7.send();
        \}
    \}
    
"
      .enabled-cells true
      .enabled-edges true
    }
    @ ./out video:container:out {
      #%graph.x 1697
      #%graph.y 399
    }
    @ ./in core:container:in {
      #%graph.x 1355
      #%graph.y 599
    }
    @ ./todo core:custom {
      #%graph.x 1389
      #%graph.y 1154
      #%graph.comment Several palettes:\n2-3 colours\n1 b/w\n1 grayscale (with one stray colour running around)\n\nTransition between palettes - mix them\n\n- coloured strobes\n- combine strobes and colours\n- use more advanced shaders on colours/strobes\n\nExperiment with movements:\n- circular\n- boids\n- phalanx
    }
    @ ./strobe-vs-shuffle core:custom {
      #%graph.x 438
      #%graph.y 79
      .code "

    @P(0) boolean trueForStrobe;
    
    @Out(0) Output strobe0;
    @Out(1) Output strobe1;
    @Out(2) Output strobe2;
    @Out(3) Output shuffle;
    
    @T(0)
    void ping0() \{
        if(trueForStrobe) \{
            strobe0.send();
        \} else \{
            shuffle.send();
        \}
    \}
    
    @T(1)
    void ping1() \{
        if(trueForStrobe) \{
            strobe1.send();
        \} else \{
            shuffle.send();
        \}
    \}
    
    @T(2)
    void ping2() \{
        if(trueForStrobe) \{
            strobe2.send();
        \} else \{
            shuffle.send();
        \}
    \}
    
"
      .true-for-strobe true
    }
    @ ./colour-control core:variable {
      #%graph.x 949
      #%graph.y 320
      .code "

    final int N = 8;
    final String SWEET\[\] = \{\"ff6530\", \"fbd06b\", \"d84248\", \"883e86\", \"658395\", \"769f85\", \"2f8cb6\", \"000000\"\};
    final String GREY\[\] = \{\"ababab\", \"e0e0e0\", \"f2f2f2\", \"b6b6b6\", \"9f9f9f\", \"4d4d4d\", \"393939\", \"000000\"\};
    final String CGA\[\] = \{\"555555\", \"5555ff\", \"55ff55\", \"55ffff\", \"ff5555\", \"ff55ff\", \"ffffff\", \"000000\"\};
    final String BW\[\] = \{\"ffffff\", \"ffffff\", \"ffffff\", \"000000\", \"000000\", \"000000\", \"000000\", \"000000\"\};
    final String RED_BW\[\] = \{\"ff0000\", \"ffffff\", \"000000\", \"000000\", \"000000\", \"000000\", \"000000\", \"000000\"\};

    List<String> current;
    List<String> target;

    @Inject String rgb0;
    @Inject String rgb1;
    @Inject String rgb2;
    @Inject String rgb3;
    @Inject String rgb4;
    @Inject String rgb5;
    @Inject String rgb6;
    @Inject String rgbEdge;

    @P(10)
    @Type.Number
    double transitionTime;

    @P(11)
    @Type.Number
    double transitionStep;
    
    @Inject
    Property r0, r1, r2, r3, r4, r5, r6, rEdge;
    @Inject
    Property g0, g1, g2, g3, g4, g5, g6, gEdge;
    @Inject
    Property b0, b1, b2, b3, b4, b5, b6, bEdge;
    @Inject
    Property t0, t1, t2, t3, t4, t5, t6, tEdge;

    @AuxOut(0)
    Output out0;
    @AuxOut(1)
    Output out1;
    @AuxOut(2)
    Output out2;
    @AuxOut(3)
    Output out3;
    @AuxOut(4)
    Output out4;
    @AuxOut(5)
    Output out5;
    @AuxOut(6)
    Output out6;
    @AuxOut(7)
    Output out7;
    
    @Inject
    Property transitionTimer;
    
    @P(50)
    boolean shuffleEnabled;

    @Override
    public void starting() \{
// causing startup  errors        
//        rgbToInts();
    \}

    @Override
    public void update() \{
        intToRgbAndSend();
    \}

    @T(0)
    void sweet() \{
        transitionToPalette(SWEET);
    \}

    @T(1)
    void grey() \{
        transitionToPalette(GREY);
    \}

    @T(3)
    void bw() \{
        transitionToPalette(BW);
    \}

    @T(4)
    void redBw() \{
        transitionToPalette(RED_BW);
    \}

//    @T(5)
//    void cga() \{
//        transitionToPalette(CGA);
//    \}
    
    
    @T(10)
    void shuffle() \{
        if(shuffleEnabled) \{
            // skipping rgbEdge
            List<String> paletteList = new ArrayList<>(Arrays.asList(rgbs()).subList(0, N-1));
            Collections.shuffle(paletteList); 
            paletteList.add(rgbs()\[N-1\]);
            transitionToPalette(paletteList.toArray(new String\[0\]), true);
        \}
    \}
    
    @T(11)
    void invert() \{
        String\[\] palette = 
                new ArrayList<>(Arrays.asList(rgbs())).stream()
                .map(this::rgbToInts)
                .map(i -> new int\[\] \{~i\[0\] & 0xff, ~i\[1\] & 0xff, ~i\[2\] & 0xff\})
                .map(this::intsToRgbString)
                .collect(Collectors.toList())
                .toArray(new String\[0\]);
        transitionToPalette(palette);
    \}
    
    @T(20)
    void whiteEdges() \{
        String\[\] palette = Arrays.copyOf(rgbs(), N);
        palette\[N-1\] = \"ffffff\";
        transitionToPalette(palette);
    \}
    
    @T(21)
    void blackEdges() \{
        String\[\] palette = Arrays.copyOf(rgbs(), N);
        palette\[N-1\] = \"000000\";
        transitionToPalette(palette);
    \}
    
    void intToRgbAndSend() \{
        for (int c = 0; c < N; ++c) \{
            int\[\] ints = new int\[\]\{i(reds()\[c\]), i(greens()\[c\]), i(blues()\[c\])\};
            setRgb(c, intsToRgbString(ints));
            outs()\[c\].send(intsToRgbInt(ints));
        \}
    \}
    
    void rgbToInts() \{
        for (int c = 0; c < N; ++c) \{
            int\[\] rgbi = rgbToInts(rgbs()\[c\]);
            reds()\[c\].set(rgbi\[0\]);
            greens()\[c\].set(rgbi\[1\]);
            blues()\[c\].set(rgbi\[2\]);
            outs()\[c\].send(intsToRgbInt(rgbi));
        \}
    \}

    void transitionToPalette(String\[\] palette) \{
        shuffleEnabled = false;
        double safeDelay = (transitionStep * (N - 1)) + transitionTime + 0.1;
        transitionTimer.set(0).to(1).in(safeDelay).whenDone(t -> \{
            transitionToPalette(palette, false);
            t.to(1).in(safeDelay).whenDone(t1 -> shuffleEnabled = true);
        \});
    \}
    
    void transitionToPalette(String\[\] palette, boolean shuffling) \{
        if(!reds()\[0\].isAnimating() && !steps()\[0\].isAnimating()) \{
            for (int c = 0; c < N; ++c) \{ 
                int i = c;
                int rgb = Integer.parseInt(palette\[i\], 16);
                int r = rgb >> 16;
                int g = (rgb & 0x00ff00) >> 8;
                int b = rgb & 0x0000ff;
                double step = transitionStep*(N-i);
                steps()\[i\].set(0).to(1).in(step).whenDone(t -> \{
                    reds()\[i\].to(r).in(transitionTime);
                    greens()\[i\].to(g).in(transitionTime);
                    blues()\[i\].to(b).in(transitionTime);
                \});
            \}
        \};
    \}
    
    String\[\] toGreyScale(String\[\] palette) \{
        String\[\] greyPalette = new String\[N\];
        for(int i=0; i<N; ++i) \{
            int\[\] rgbi = rgbToInts(palette\[i\]);
            int grey = (rgbi\[0\] + rgbi\[1\] + rgbi\[2\])/3;
            greyPalette\[i\] = intsToRgbString(new int\[\] \{grey, grey, grey\});
        \}
        return greyPalette;
    \}

    void setRgb(int i, String rgb) \{
        if (0 == i) \{
            rgb0 = rgb;
        \} else if (1 == i) \{
            rgb1 = rgb;
        \} else if (2 == i) \{
            rgb2 = rgb;
        \} else if (3 == i) \{
            rgb3 = rgb;
        \} else if (4 == i) \{
            rgb4 = rgb;
        \} else if (5 == i) \{
            rgb5 = rgb;
        \} else if (6 == i) \{
            rgb6 = rgb;
        \} else if (7 == i) \{
            rgbEdge = rgb;
        \}
    \}

    int\[\] rgbToInts(String rgb) \{
        int i = Integer.parseInt(rgb, 16);
        return new int\[\]\{i >> 16, (i & 0x00ff00) >> 8, i & 0x0000ff\};
    \}

    String intsToRgbString(int rgb\[\]) \{
        return String.format(\"%02X%02X%02X\", rgb\[0\], rgb\[1\], rgb\[2\]);
    \}

    int intsToRgbInt(int rgb\[\]) \{
        return (rgb\[0\] << 16) + (rgb\[1\] << 8) + rgb\[2\];
    \}

    String\[\] rgbs() \{
        return new String\[\]\{rgb0, rgb1, rgb2, rgb3, rgb4, rgb5, rgb6, rgbEdge\};
    \}

    Property\[\] reds() \{
        return new Property\[\]\{r0, r1, r2, r3, r4, r5, r6, rEdge\};
    \}

    Property\[\] greens() \{
        return new Property\[\]\{g0, g1, g2, g3, g4, g5, g6, gEdge\};
    \}

    Property\[\] blues() \{
        return new Property\[\]\{b0, b1, b2, b3, b4, b5, b6, bEdge\};
    \}

    Property\[\] steps() \{
        return new Property\[\]\{t0, t1, t2, t3, t4, t5, t6, tEdge\};
    \}

    Output\[\] outs() \{
        return new Output\[\]\{out0, out1, out2, out3, out4, out5, out6, out7\};
    \}
"
      .transition-time 0.1
      .transition-step 0.1
      .shuffle-enabled true
    }
    @ ./colours core:container {
      #%graph.x 1273
      #%graph.y 379
      #%praxis.version 4.1.1
      @ ./colour-1 video:gl:p2d {
        #%graph.x 159
        #%graph.y 20
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -16777216
        .hex-rgb 000000
      }
      @ ./colour-3 video:gl:p2d {
        #%graph.x 435
        #%graph.y 120
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -16777216
        .hex-rgb 000000
      }
      @ ./colour-4 video:gl:p2d {
        #%graph.x 573
        #%graph.y 170
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -16777216
        .hex-rgb 000000
      }
      @ ./colour-5 video:gl:p2d {
        #%graph.x 711
        #%graph.y 220
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -16777216
        .hex-rgb 000000
      }
      @ ./colour-6 video:gl:p2d {
        #%graph.x 849
        #%graph.y 270
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -16777216
        .hex-rgb 000000
      }
      @ ./colour-2 video:gl:p2d {
        #%graph.x 297
        #%graph.y 70
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -16777216
        .hex-rgb 000000
      }
      @ ./colour-0 video:gl:p2d {
        #%graph.x 21
        #%graph.y -30
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -47453
        .hex-rgb FF46A3
        .red 255.0
        .green 70.9090909090909
        .blue 163.63636363636363
        .hue 0.9162161946296692
        .saturation 0.7254902124404907
        .brightness 1.0
      }
      @ ./colour-7 video:gl:p2d {
        #%graph.x 987
        #%graph.y 320
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -16777216
        .hex-rgb 000000
      }
      @ ./out-0 video:container:out {
        #%graph.x 1180
        #%graph.y -30
      }
      @ ./out-1 video:container:out {
        #%graph.x 1180
        #%graph.y 20
      }
      @ ./out-2 video:container:out {
        #%graph.x 1180
        #%graph.y 70
      }
      @ ./out-3 video:container:out {
        #%graph.x 1180
        #%graph.y 120
      }
      @ ./out-4 video:container:out {
        #%graph.x 1180
        #%graph.y 170
      }
      @ ./out-5 video:container:out {
        #%graph.x 1180
        #%graph.y 220
      }
      @ ./out-6 video:container:out {
        #%graph.x 1180
        #%graph.y 270
      }
      @ ./out-7 video:container:out {
        #%graph.x 1180
        #%graph.y 320
      }
      @ ./in-0 core:container:in {
        #%graph.x -228
        #%graph.y -5
      }
      @ ./in-1 core:container:in {
        #%graph.x -228
        #%graph.y 45
      }
      @ ./in-2 core:container:in {
        #%graph.x -228
        #%graph.y 95
      }
      @ ./in-3 core:container:in {
        #%graph.x -228
        #%graph.y 145
      }
      @ ./in-4 core:container:in {
        #%graph.x -228
        #%graph.y 195
      }
      @ ./in-5 core:container:in {
        #%graph.x -228
        #%graph.y 245
      }
      @ ./in-6 core:container:in {
        #%graph.x -228
        #%graph.y 295
      }
      @ ./in-7 core:container:in {
        #%graph.x -228
        #%graph.y 345
      }
      ~ ./colour-0!out ./out-0!in
      ~ ./colour-1!out ./out-1!in
      ~ ./colour-2!out ./out-2!in
      ~ ./colour-3!out ./out-3!in
      ~ ./colour-4!out ./out-4!in
      ~ ./colour-5!out ./out-5!in
      ~ ./colour-6!out ./out-6!in
      ~ ./colour-7!out ./out-7!in
      ~ ./in-1!out ./colour-1!int-rgb
      ~ ./in-2!out ./colour-2!int-rgb
      ~ ./in-3!out ./colour-3!int-rgb
      ~ ./in-4!out ./colour-4!int-rgb
      ~ ./in-5!out ./colour-5!int-rgb
      ~ ./in-6!out ./colour-6!int-rgb
      ~ ./in-7!out ./colour-7!int-rgb
      ~ ./in-0!out ./colour-0!int-rgb
    }
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./properties-in!out ./control!properties-in
    ~ ./control!properties-out ./properties-out!in
    ~ ./strobe-control!out-0 ./strobes!in-0
    ~ ./strobe-control!out-1 ./strobes!in-1
    ~ ./strobe-control!out-2 ./strobes!in-2
    ~ ./strobe-control!out-3 ./strobes!in-3
    ~ ./in!out ./vor-colours!voronoi-in
    ~ ./vor-colours!out ./out!in
    ~ ./strobes!out-7 ./vor-colours!in-edges
    ~ ./strobes!out-1 ./vor-colours!in-6
    ~ ./strobes!out-0 ./vor-colours!in-5
    ~ ./strobe-control!edges-7 ./strobes!in-7
    ~ ./strobes!out-1 ./vor-colours!in-4
    ~ ./ping-control!ping-1-yellow ./strobe-vs-shuffle!ping-1
    ~ ./strobe-vs-shuffle!strobe-1 ./strobe-control!strobe-1
    ~ ./strobe-vs-shuffle!strobe-0 ./strobe-control!strobe-0
    ~ ./control!true-strobe-false-shuffle ./strobe-vs-shuffle!true-for-strobe
    ~ ./ping-control!ping-2-cyan ./strobe-control!strobe-edges
    ~ ./control!grey ./colour-control!grey
    ~ ./control!colours ./colour-control!sweet
    ~ ./strobe-vs-shuffle!shuffle ./colour-control!shuffle
    ~ ./colour-control!out-1 ./colours!in-1
    ~ ./colour-control!out-2 ./colours!in-2
    ~ ./colour-control!out-3 ./colours!in-3
    ~ ./colour-control!out-4 ./colours!in-4
    ~ ./colour-control!out-5 ./colours!in-5
    ~ ./colour-control!out-6 ./colours!in-6
    ~ ./colour-control!out-7 ./colours!in-7
    ~ ./colours!out-0 ./vor-colours!in-0
    ~ ./colours!out-1 ./vor-colours!in-1
    ~ ./colours!out-2 ./vor-colours!in-2
    ~ ./colours!out-3 ./vor-colours!in-3
    ~ ./colours!out-4 ./vor-colours!in-4
    ~ ./colours!out-5 ./vor-colours!in-5
    ~ ./colours!out-6 ./vor-colours!in-6
    ~ ./colours!out-7 ./vor-colours!in-edges
  }
  @ ./colours-control core:routing:send {
    #%graph.x 660
    #%graph.y 953
    .address /video/colours/properties-in.in
  }
  @ ./start core:start-trigger {
    #%graph.x 220
    #%graph.y 518
  }
  @ ./videos core:container {
    #%graph.x 954
    #%graph.y 518
    #%praxis.version 4.1.1
    .ports "voronoi-pipe-in \"vor-colours!voronoi-pipe-in\""
    @ ./vor-colours video:gl:p2d {
      #%graph.x 1041
      #%graph.y 193
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 7
      .edge-width 0.0
      .draw-cells true
      .just-colours false
    }
    @ ./control core:custom {
      #%graph.x 265
      #%graph.y 395
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.randomly;
    final double MOVEMENT_SPEED = 80;
    final double TIME_TO_MOVE = .2;
    final int MOVE_TO_CENTRE = 0;
    final int CELLS_COUNT = 9;
    final double TRANSITION_TIME = 10;
    
    @Out(10) Output videoStart;
    @Out(11) Output screenshotOut;
    @Out(12) Output praxisOut;
    @Out(13) Output tidalOut;
    
    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(0)
    void buildings() \{
        activate();
        videoStart.send();
    \}
    
    @T(1)
    void screenshot() \{
        activate();
        screenshotOut.send();
    \}
    
    @T(2)
    void praxis() \{
        activate();
        praxisOut.send();
    \}
    
    @T(3)
    void tidal() \{
        activate();
        tidalOut.send();
    \}
    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @Out(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @Out(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x 445
      #%graph.y 694
      .address /video/x-fader.to-videos
    }
    @ ./ping-control core:custom {
      #%graph.x 8
      #%graph.y 14
      .code "
    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    
    @T(10) void ping0RedIn() \{
        ping0Red.send();
    \}
    @T(11) void ping1YellowIn() \{
        ping1Yellow.send();
    \}
    @T(12) void ping2CyanIn() \{
        ping2Cyan.send();
    \}
"
    }
    @ ./properties-out core:routing:send {
      #%graph.x 445
      #%graph.y 622
      .address /video/voronoi-generator.properties-in
    }
    @ ./strobes core:container {
      #%graph.x 568
      #%graph.y 37
      #%praxis.version 4.1.1
      @ ./strobe-0 video:gl:p2d {
        #%graph.x 92
        #%graph.y -3
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-0 video:container:out {
        #%graph.x 1301
        #%graph.y -3
      }
      @ ./strobe-1 video:gl:p2d {
        #%graph.x 232
        #%graph.y 47
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-1 video:container:out {
        #%graph.x 1301
        #%graph.y 47
      }
      @ ./strobe-2 video:gl:p2d {
        #%graph.x 372
        #%graph.y 97
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-2 video:container:out {
        #%graph.x 1301
        #%graph.y 97
      }
      @ ./strobe-3 video:gl:p2d {
        #%graph.x 512
        #%graph.y 147
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-3 video:container:out {
        #%graph.x 1301
        #%graph.y 147
      }
      @ ./strobe-7 video:gl:p2d {
        #%graph.x 1072
        #%graph.y 347
        .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
        .ease 0.2
        .red 255.0
        .green 255.0
        .blue 255.0
        .brightness 1.0
        .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
      }
      @ ./out-7 video:container:out {
        #%graph.x 1301
        #%graph.y 347
      }
      @ ./in-0 core:container:in {
        #%graph.x -134
        #%graph.y -3
      }
      @ ./in-1 core:container:in {
        #%graph.x -134
        #%graph.y 47
      }
      @ ./in-2 core:container:in {
        #%graph.x -134
        #%graph.y 97
      }
      @ ./in-3 core:container:in {
        #%graph.x -134
        #%graph.y 147
      }
      @ ./in-7 core:container:in {
        #%graph.x -134
        #%graph.y 347
      }
      ~ ./strobe-0!out ./out-0!in
      ~ ./strobe-1!out ./out-1!in
      ~ ./strobe-2!out ./out-2!in
      ~ ./strobe-3!out ./out-3!in
      ~ ./strobe-7!out ./out-7!in
      ~ ./in-0!out ./strobe-0!strobe
      ~ ./in-1!out ./strobe-1!strobe
      ~ ./in-2!out ./strobe-2!strobe
      ~ ./in-3!out ./strobe-3!strobe
      ~ ./in-7!out ./strobe-7!strobe
    }
    @ ./strobe-control core:timing:timer {
      #%graph.x 240
      #%graph.y 37
      .code "import org.praxislive.video.pgl.code.userapi.PImage;


    @Out(0) Output out0;
    @Out(1) Output out1;
    @Out(2) Output out2;
    @Out(3) Output out3;
    @Out(7) Output edges7;
    
    @P(1) boolean enabledCells;
    @P(2) boolean enabledEdges;
    
    @T(0) public void strobe0() \{ 
        if(enabledCells) \{
            out0.send();
        \}
    \}
    
    @T(1)
    public void strobe1() \{
        if(enabledCells) \{
            out1.send();
        \}
    \}

    @T(2)
    public void strobe2() \{
        if(enabledCells) \{
            out2.send();
        \}
    \}

    @T(3)
    public void strobe3() \{
        if(enabledCells) \{
            out3.send();
        \}
    \}

    @T(7)
    public void strobeEdges() \{
        if(enabledEdges) \{
            edges7.send();
        \}
    \}
    
"
      .enabled-cells true
      .enabled-edges true
    }
    @ ./out video:container:out {
      #%graph.x 1250
      #%graph.y 393
    }
    @ ./videos core:container {
      #%graph.x 568
      #%graph.y 343
      #%praxis.version 4.1.1
      @ ./colour-0 video:gl:p2d {
        #%graph.x 266
        #%graph.y 680
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -15054849
        .hex-rgb 1A47FF
        .red 26.0
        .green 71.0
        .blue 255.0
        .hue 0.6339421272277832
        .saturation 0.8975409865379333
        .brightness 1.0
      }
      @ ./player-buildings video:player {
        #%graph.x -351
        #%graph.y 369
        .code "import org.praxislive.video.gstreamer.*;


    enum ResizeMode \{Stretch, Scale, Crop\};
    
    @T(0) Trigger rewindAndPlay;
    @T(1) Trigger play;
    @T(2) Trigger pause;
    @T(3) Trigger stop;
    
    @P(1) @Type(value = PResource.class, properties = \{PResource.KEY_ALLOW_EMPTY, \"true\"\})
    Property video;
    @P(2) @OnChange(\"seek\") @Type.Number(min = 0, max = 1)
    double position;
    @P(3) @Type.Number(def = 1)
    Property rate;
    @P(4) @Type.Boolean(def = true)
    Property loop;
    @P(5)
    ResizeMode resizeMode;
    @P(6) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignX;
    @P(7) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignY;
    @P(8) @Type.Number(min = 0, max = 8, def = 1, skew = 4)
    double zoom;
    @P(9) @Type.String(suggested = \"autoaudiosink\") @Config.Port(false)
    Property audioSink;
    @P(10) @ReadOnly
    String state;
    
    @Inject VideoPlayer player;

    @AuxOut(1) Output ready;
    @AuxOut(2) Output error;
    @AuxOut(3) Output eos;
    

    @Override
    public void init() \{
        video.linkAs(PResource::from, player::location);
        rate.link(player::rate);
        loop.valuesAs(PBoolean.class).link(b -> player.looping(b.value()));
        rewindAndPlay.link(() -> \{ 
            position = 0;
            seek();
            player.play();
        \});
        play.link(player::play);
        pause.link(player::pause);
        stop.link(player::stop);
        audioSink.linkAs(Value::toString, player::audioSink);
        player.onReady(ready::send);
        player.onError(msg -> \{
            log(ERROR, msg);
            error.send(msg);
        \});
        player.onEOS(eos::send);
    \}

    @Override
    public void draw() \{
        if (player.render(this::drawFrame)) \{
            position = player.position();
        \} else \{
            position = 0;
        \}
        state = player.state().toString();
    \}

    void drawFrame(PImage frame) \{
        double outWidth = zoom * frame.width;
        double outHeight = zoom * frame.height;
        if (resizeMode == ResizeMode.Stretch) \{
            outWidth *= (double) width / frame.width;
            outHeight *= (double) height / frame.height;
        \} else if (resizeMode == ResizeMode.Scale) \{
            double r = min((double) width / frame.width, (double) height / frame.height);
            outWidth *= r;
            outHeight *= r;
        \}
        image(frame, alignX * (width - outWidth),
                alignY * (height - outHeight),
                outWidth,
                outHeight);
    \}
    
    void seek() \{
        player.position(position);
    \}

"
        .video file:/home/anton/Videos/Hacksmith/Terribilis/TerribilisBackProj.mp4
        .zoom 0.9647030208767181
      }
      @ ./colour-correction-1 video:gl:p2d {
        #%graph.x 196
        #%graph.y 491
        #%graph.comment \n
        .code "

    @In(1)
    PImage in;
    @P(-2)
    @Type.String(mime = GLSL_VERTEX_MIME, template = DEFAULT_VERTEX_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String vertex;
    @P(-1)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @P(2)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double contrast;
    @P(3)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double saturation;
    @P(4)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double brightness;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{

        if (shader == null) \{
            shader = createShader(
                    vertex.isEmpty() ? DEFAULT_VERTEX_SHADER : vertex,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        shader.set(\"RENDERSIZE\", width, height);
        updateUniforms();
        noStroke();
        beginShape(QUADS);
        vertex(0, 0, 0, 0);
        vertex(width, 0, 1, 0);
        vertex(width, height, 1, 1);
        vertex(0, height, 0, 1);
        endShape();
        resetShader();

    \}

    void updateUniforms() \{
        shader.set(\"inputImage\", in);
        shader.set(\"contrast\", contrast);
        shader.set(\"saturation\", saturation);
        shader.set(\"brightness\", brightness);
    \}

    void updateShader() \{
        shader = null;
    \}
"
        .vertex "uniform mat4 transformMatrix;
uniform mat4 inputImageMatrix;

attribute vec4 position;
attribute vec2 texCoord;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

void main() \{
  isf_FragNormCoord = texCoord;
  isf_FragCoord = position.xy;
  gl_Position = transformMatrix * position;
\}"
        .fragment "uniform sampler2D inputImage;
uniform mat4 inputImageMatrix;

uniform float contrast;
uniform float saturation;
uniform float brightness;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

vec3 rgb2hsv(vec3 c)	\{
	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
	vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
	
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
\}

vec3 hsv2rgb(vec3 c)	\{
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
\}

void main()
\{
	vec4 inColor = texture2D(inputImage, (inputImageMatrix * vec4(isf_FragNormCoord, 1.0, 1.0)).xy); 
	vec3 outColor = rgb2hsv(inColor.rgb);
        outColor.g *= saturation;
        outColor.rgb = hsv2rgb(outColor);
        outColor.rgb = outColor.rgb*contrast;
	outColor.rgb += vec3(brightness, brightness, brightness)-vec3(1,1,1);
	gl_FragColor.rgb = outColor.rgb;
        gl_FragColor.a = 1.0;
\}




"
        .contrast 2.079874126521357
        .saturation 0.0
        .brightness 0.648619431557137
      }
      @ ./video-out-plain video:container:out {
        #%graph.x 757
        #%graph.y 361
      }
      @ ./video-out-composite-1 video:container:out {
        #%graph.x 951
        #%graph.y 719
      }
      @ ./video-out-composite-0 video:container:out {
        #%graph.x 970
        #%graph.y 541
      }
      @ ./composite-0 video:composite {
        #%graph.x 724
        #%graph.y 494
        .mode BitXor
        .mix 0.36936936936936937
      }
      @ ./composite-1 video:composite {
        #%graph.x 682
        #%graph.y 704
        .mode BitXor
        .mix 0.4144144144144144
      }
      @ ./colour-1 video:gl:p2d {
        #%graph.x 444
        #%graph.y 714
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -171008
        .hex-rgb FD6400
        .red 253.0
        .green 100.0
        .hue 0.06599552184343338
        .saturation 1.0
        .brightness 0.9933333333333333
      }
      @ ./start core:container:in {
        #%graph.x -543
        #%graph.y 290
      }
      @ ./solarize video:gl:p2d {
        #%graph.x -31
        #%graph.y 416
        #%graph.comment Solarizes an image\nby VIDVOX\nCategories : Glitch
        .code "

    @In(1)
    PImage in;
    @P(-2)
    @Type.String(mime = GLSL_VERTEX_MIME, template = DEFAULT_VERTEX_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String vertex;
    @P(-1)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @P(1)
    @Type.Number(min = 0, max = 1, def = 0.5)
    double centerBrightness;
    @P(2)
    @Type.Number(min = 0, max = 4, def = 1)
    double powerCurve;
    @P(3)
    @Type.Number(min = 0, max = 1, def = 0)
    double colorize;
    @P(4)
    @Type.Boolean(def = false)
    boolean inverse;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{

        if (shader == null) \{
            shader = createShader(
                    vertex.isEmpty() ? DEFAULT_VERTEX_SHADER : vertex,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        shader.set(\"RENDERSIZE\", width, height);
        updateUniforms();
        noStroke();
        beginShape(QUADS);
        vertex(0, 0, 0, 0);
        vertex(width, 0, 1, 0);
        vertex(width, height, 1, 1);
        vertex(0, height, 0, 1);
        endShape();
        resetShader();

    \}

    void updateUniforms() \{
        shader.set(\"inputImage\", in);
        shader.set(\"centerBrightness\", centerBrightness);
        shader.set(\"powerCurve\", powerCurve);
        shader.set(\"colorize\", colorize);
        shader.set(\"inverse\", inverse);
    \}

    void updateShader() \{
        shader = null;
    \}
"
        .vertex "uniform mat4 transformMatrix;
uniform mat4 inputImageMatrix;

attribute vec4 position;
attribute vec2 texCoord;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

void main() \{
  isf_FragNormCoord = texCoord;
  isf_FragCoord = position.xy;
  gl_Position = transformMatrix * position;
\}"
        .fragment "uniform sampler2D inputImage;
uniform mat4 inputImageMatrix;

uniform float centerBrightness;
uniform float powerCurve;
uniform float colorize;
uniform bool inverse;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

vec3 rgb2hsv(vec3 c)	\{
	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
	vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
	
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
\}

vec3 hsv2rgb(vec3 c)	\{
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
\}




void main()
\{
	vec4		inColor = texture2D(inputImage, (inputImageMatrix * vec4(isf_FragNormCoord, 1.0, 1.0)).xy); 
	vec4		hslColor;
	vec4		outColor;
	
	//	convert to HSV
	hslColor.rgb = rgb2hsv(inColor.rgb);
	outColor.rgb = hslColor.rgb;
	outColor.a = inColor.a;
	
	//	drop the saturation
	//outColor.g = 0.0;
	
	//	adjust the brightness curve
	outColor.b = pow(outColor.b, powerCurve);
	outColor.b = (outColor.b < centerBrightness) ? (1.0 - outColor.b / centerBrightness) : (outColor.b - centerBrightness) / centerBrightness;
	outColor.b = (inverse) ? 1.0 - outColor.b : outColor.b;
	
	outColor.g = (inverse) ? outColor.g * (1.0-hslColor.b) * colorize : outColor.g * hslColor.b * colorize;
	
	//	convert back to rgb
	outColor.rgb = hsv2rgb(outColor.rgb);
	
	gl_FragColor = outColor;
\}




"
        .center-brightness 0.15333333333333332
        .power-curve 1.7333333333333334
        .inverse true
      }
      ~ ./colour-correction-1!out ./video-out-plain!in
      ~ ./colour-correction-1!out ./composite-0!in
      ~ ./colour-0!out ./composite-0!src
      ~ ./composite-0!out ./video-out-composite-0!in
      ~ ./colour-1!out ./composite-1!src
      ~ ./colour-correction-1!out ./composite-1!in
      ~ ./composite-1!out ./video-out-composite-1!in
      ~ ./start!out ./player-buildings!play
      ~ ./player-buildings!out ./solarize!in
      ~ ./solarize!out ./colour-correction-1!in
    }
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./control!properties-out ./properties-out!in
    ~ ./strobe-control!out-0 ./strobes!in-0
    ~ ./strobe-control!out-1 ./strobes!in-1
    ~ ./strobe-control!out-2 ./strobes!in-2
    ~ ./strobe-control!out-3 ./strobes!in-3
    ~ ./vor-colours!out ./out!in
    ~ ./strobe-control!edges-7 ./strobes!in-7
    ~ ./strobes!out-0 ./vor-colours!in-0
    ~ ./ping-control!ping-0-red ./strobe-control!strobe-0
    ~ ./ping-control!ping-1-yellow ./strobe-control!strobe-1
    ~ ./videos!video-out-composite-0 ./vor-colours!in-6
    ~ ./videos!video-out-composite-1 ./vor-colours!in-5
    ~ ./videos!video-out-plain ./vor-colours!in-4
    ~ ./videos!video-out-plain ./vor-colours!in-3
    ~ ./videos!video-out-plain ./vor-colours!in-2
    ~ ./ping-control!ping-2-cyan ./strobe-control!strobe-2
    ~ ./strobes!out-2 ./vor-colours!in-6
    ~ ./strobes!out-1 ./vor-colours!in-5
    ~ ./control!video-start ./videos!start
    ~ ./videos!video-out-plain ./vor-colours!in-1
  }
  @ ./videos-control core:routing:send {
    #%graph.x 663
    #%graph.y 1003
    .code "

    Optional<ControlAddress>\[\] addresses;
    
    @Override public void init() \{
        String\[\] listeners = new String\[\] \{
            \"/video/city-buildings/control.properties-in\",
            \"/video/explosion/control.properties-in\",
            \"/video/bubbles/control.properties-in\",
            \"/video/experiment/control.properties-in\",
            \"/video/videos/control.properties-in\"
        \};
        addresses = Stream.of(listeners).map((address) -> \{
            try \{
                return Optional.of(ControlAddress.parse(address));
            \} catch (ValueFormatException e) \{
                log(ERROR, \"Weird address: \" + address);
                return Optional.empty();
            \}
        \}).toArray(Optional\[\]::new);
    \}
    
    @In(1) void in(Value value) throws ValueFormatException \{
        Stream.of(addresses).forEach((opt) -> opt.ifPresent(destination -> tell(destination, value)));
    \}

"
  }
  @ ./explosion core:container {
    #%graph.x 954
    #%graph.y 707
    #%praxis.version 4.4.0
    .ports "out \"voronoi-renderer!out\" voronoi-pipe-in \"voronoi-renderer!voronoi-pipe-in\""
    @ ./ping-control core:custom {
      #%graph.x 69
      #%graph.y 86
      .code "

    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @P(13) @OnChange(\"onPingCombinedIn\") int pingCombinedIn;
    
    @T(10) void ping0RedIn() \{
        ping0Red.send();
    \}
    @T(11) void ping1YellowIn() \{
        ping1Yellow.send();
    \}
    @T(12) void ping2CyanIn() \{
        ping2Cyan.send();
    \}
    
    void onPingCombinedIn() \{
        if (0 == pingCombinedIn) \{ 
            ping0RedIn();
        \} else if (1 == pingCombinedIn) \{
            ping1YellowIn();
        \} else if (2 == pingCombinedIn) \{
            ping2CyanIn();
        \} else \{
            log(ERROR, \"Weird ping: \" + pingCombinedIn);
        \}
    \}
"
      .ping-combined-in 1
    }
    @ ./explosion video:gl:p2d {
      #%graph.x 824
      #%graph.y 37
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property brightness;
    double lastFlash = 0;

    void updateUniforms() \{
        shader.set(\"resolution\", width, height);
        shader.set(\"brightness\", d(brightness));
        shader.set(\"time\", millis()/1000.0);
    \}
    
    @T(1) void flash() \{
        if (millis() - lastFlash > 400) \{
            lastFlash = millis();
            brightness.to(0.2).in(0.2).easeOut().whenDone(p1 ->  \{
                brightness.to(1.2).in(0.2).easeOut();
            \});
        \}
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
        flash();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "uniform vec2 resolution;
uniform float position;
uniform float brightness;
uniform float time;

vec4 cellColor = vec4(0.0,0.0,0.0,0.0);
vec3 cellPosition = vec3(0.0,0.0,0.0);
float cellRandom = 0.0, onOffRandom = 0.0;


float random (vec3 i)\{
	return fract(sin(dot(i.xyz,vec3(4154895.34636,8616.15646,26968.489)))*968423.156);
\}

vec4 getColorFromFloat (float i)\{
    i *= 2000.0;
    return vec4(normalize(vec3(abs(sin(i+radians(45.0))),abs(sin(i+radians(90.0))),abs(sin(i)))),1.0);
\}

vec3 getPositionFromFloat (float i)\{
    i *= 2000.0;
    return vec3(normalize(vec3(abs(sin(i+radians(45.0))),abs(sin(i+radians(90.0))),abs(sin(i)))))-vec3(0.5,0.5,0.5);
\}

float map(vec3 p)\{
    //p *= 1.0;
    cellRandom = random(floor((p*0.5)+0.0*vec3(0.5,0.5,0.5)));
    onOffRandom = random(vec3(5.0,2.0,200.0)+floor((p*0.5)+0.0*vec3(0.5,0.5,0.5)));
    cellColor = getColorFromFloat(cellRandom);
    cellPosition = getPositionFromFloat(cellRandom);
    p.x = mod(p.x, 2.0);
    p.y = mod(p.y, 2.0);
    p.z = mod(p.z, 2.0);
    p += 1.0*cellPosition.xyz;
    p += p.xyz*sin(10.0*time+onOffRandom*300.0)*			0.05;
    p += p.yzx*cos(10.0*time+onOffRandom*300.0+1561.355)*	0.05;
    if(onOffRandom>0.5)\{
    	return length(p-vec3(1.0,1.0,1.0)) - 0.2*cellRandom+0.02*(sin(time*20.0*onOffRandom+cellRandom*2000.0));
    \} else \{
        return 1.0;
    \}
\}

float trace(vec3 o, vec3 r)\{
    float t = 0.5;
    const int maxSteps = 48;
    for (int i = 0; i < maxSteps; i++)\{ 
        vec3 p = o + r * t;
        float d = map(p);
        t += d*0.35;
    \}
    return t;
\}

void main()
\{
	vec2 uv = gl_FragCoord.xy / resolution.xy;
    uv = uv*2.0 -1.0;
    uv.x *= resolution.x / resolution.y;
    vec3 r = normalize(vec3(uv, 1.0));
    r = r*0.1+cross(r,vec3(0.0,1.0,-1.0));
    vec3 o;
    o.z = 8.5*time;
    o += vec3(0.52,0.5,-3.0);
    
    
    float t = trace(o,r)*brightness*0.98;
    float fog = 1.0 / (1.0 + t * t * 0.1);
    vec3 fc = vec3(fog);
    
	gl_FragColor = vec4(fc*vec3(28.0,10.0+-1.0*length(uv+vec2(0.0,1.0)),6.4)*0.6/length(uv+vec2(0.0,1.0))*1.0,1.0);
\}"
    }
    @ ./grey-palette core:container {
      #%graph.x 855
      #%graph.y 460
      #%praxis.version 4.4.0
      .ports "colour-0-out \"colour-0!out\" colour-1-out \"colour-1!out\" colour-2-out \"colour-2!out\" colour-3-out \"colour-3!out\" colour-4-out \"colour-4!out\" colour-5-out \"colour-5!out\" colour-6-out \"colour-6!out\" colour-7-out \"colour-7!out\""
      @ ./colour-1 video:gl:p2d {
        #%graph.x 620
        #%graph.y 367
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -12105913
        .hex-rgb 474747
        .red 71.0
        .green 71.0
        .blue 71.0
        .brightness 0.27976190476190477
      }
      @ ./colour-3 video:gl:p2d {
        #%graph.x 896
        #%graph.y 467
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -12369085
        .hex-rgb 434343
        .red 67.0
        .green 67.0
        .blue 67.0
        .brightness 0.2619047619047619
      }
      @ ./colour-4 video:gl:p2d {
        #%graph.x 1034
        #%graph.y 517
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -12961222
        .hex-rgb 3A3A3A
        .red 58.0
        .green 58.0
        .blue 58.0
        .brightness 0.2261904761904762
      }
      @ ./colour-5 video:gl:p2d {
        #%graph.x 1172
        #%graph.y 567
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -11711155
        .hex-rgb 4D4D4D
        .red 77.0
        .green 77.0
        .blue 77.0
        .brightness 0.3019607961177826
      }
      @ ./colour-6 video:gl:p2d {
        #%graph.x 1310
        #%graph.y 617
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -13882324
        .hex-rgb 2C2C2C
        .red 44.0
        .green 44.0
        .blue 44.0
        .brightness 0.17261904761904762
      }
      @ ./colour-2 video:gl:p2d {
        #%graph.x 758
        #%graph.y 417
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -10197916
        .hex-rgb 646464
        .red 100.0
        .green 100.0
        .blue 100.0
        .brightness 0.39285714285714285
      }
      @ ./colour-0 video:gl:p2d {
        #%graph.x 482
        #%graph.y 317
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -10461088
        .hex-rgb 606060
        .red 96.0
        .green 96.0
        .blue 96.0
        .brightness 0.375
      }
      @ ./colour-7 video:gl:p2d {
        #%graph.x 1448
        #%graph.y 667
        .code "import java.awt.Color;

@P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -15198184
        .hex-rgb 181818
        .red 24.0
        .green 24.0
        .blue 24.0
        .brightness 0.09523809523809523
      }
    }
    @ ./voronoi-renderer video:gl:p2d {
      #%graph.x 1078
      #%graph.y 210
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;


    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 7
      .edge-width 8
      .draw-cells true
      .just-colours false
    }
    @ ./strobe-0 video:gl:p2d {
      #%graph.x 568
      #%graph.y 261
      #%graph.minimized true
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-1 video:gl:p2d {
      #%graph.x 568
      #%graph.y 210
      #%graph.minimized true
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-2 video:gl:p2d {
      #%graph.x 568
      #%graph.y 318
      #%graph.minimized true
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./control core:custom {
      #%graph.x 110
      #%graph.y 480
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.randomly;
    final double MOVEMENT_SPEED = 28;
    final double TIME_TO_MOVE = 1;
    final int MOVE_TO_CENTRE = 1;
    final int CELLS_COUNT = 36;
    final double TRANSITION_TIME = 10;


    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(1)
    void explosion() \{
        activate();
    \}

    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @AuxOut(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @AuxOut(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x 395
      #%graph.y 705
      .address /video/x-fader.to-explosion
    }
    @ ./properties-out core:routing:send {
      #%graph.x 396
      #%graph.y 607
      .address /video/voronoi-generator.properties-in
    }
    ~ ./grey-palette!colour-0-out ./voronoi-renderer!in-0
    ~ ./grey-palette!colour-1-out ./voronoi-renderer!in-1
    ~ ./grey-palette!colour-2-out ./voronoi-renderer!in-2
    ~ ./grey-palette!colour-3-out ./voronoi-renderer!in-3
    ~ ./grey-palette!colour-4-out ./voronoi-renderer!in-4
    ~ ./grey-palette!colour-5-out ./voronoi-renderer!in-5
    ~ ./grey-palette!colour-6-out ./voronoi-renderer!in-6
    ~ ./grey-palette!colour-7-out ./voronoi-renderer!in-edges
    ~ ./explosion!out ./voronoi-renderer!in-0
    ~ ./explosion!out ./voronoi-renderer!in-1
    ~ ./explosion!out ./voronoi-renderer!in-2
    ~ ./explosion!out ./voronoi-renderer!in-3
    ~ ./explosion!out ./voronoi-renderer!in-4
    ~ ./explosion!out ./voronoi-renderer!in-5
    ~ ./explosion!out ./voronoi-renderer!in-6
    ~ ./ping-control!ping-1-yellow ./explosion!flash
    ~ ./strobe-0!out ./voronoi-renderer!in-edges
    ~ ./ping-control!ping-1-yellow ./strobe-0!strobe
    ~ ./strobe-1!out ./voronoi-renderer!in-0
    ~ ./strobe-1!out ./voronoi-renderer!in-1
    ~ ./ping-control!ping-2-cyan ./strobe-2!strobe
    ~ ./strobe-2!out ./voronoi-renderer!in-2
    ~ ./control!properties-out ./properties-out!in
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./ping-control!ping-0-red ./strobe-1!strobe
  }
  @ ./city-buildings core:container {
    #%graph.x 954
    #%graph.y 609
    #%praxis.version 4.4.0
    .ports "out \"voronoi-renderer!out\" voronoi-pipe-in \"voronoi-renderer!voronoi-pipe-in\""
    @ ./voronoi-renderer video:gl:p2d {
      #%graph.x 1317
      #%graph.y 114
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 7
      .edge-width 36.01846585234666
      .draw-cells true
      .just-colours false
    }
    @ ./movies core:container {
      #%graph.x 276
      #%graph.y 352
      #%praxis.version 4.4.0
      .ports "out \"colour-correction-1!out\" composite-0-out \"composite-0!out\" composite-1-out \"composite-1!out\""
      @ ./player-buildings video:player {
        #%graph.x 285
        #%graph.y 69
        .code "import org.praxislive.video.gstreamer.*;


    enum ResizeMode \{Stretch, Scale, Crop\};
    
    @T(0) Trigger rewindAndPlay;
    @T(1) Trigger play;
    @T(2) Trigger pause;
    @T(3) Trigger stop;
    
    @P(1) @Type(value = PResource.class, properties = \{PResource.KEY_ALLOW_EMPTY, \"true\"\})
    Property video;
    @P(2) @OnChange(\"seek\") @Type.Number(min = 0, max = 1)
    double position;
    @P(3) @Type.Number(def = 1)
    Property rate;
    @P(4) @Type.Boolean(def = true)
    Property loop;
    @P(5)
    ResizeMode resizeMode;
    @P(6) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignX;
    @P(7) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignY;
    @P(8) @Type.Number(min = 0, max = 8, def = 1, skew = 4)
    double zoom;
    @P(9) @Type.String(suggested = \"autoaudiosink\") @Config.Port(false)
    Property audioSink;
    @P(10) @ReadOnly
    String state;
    
    @Inject VideoPlayer player;

    @AuxOut(1) Output ready;
    @AuxOut(2) Output error;
    @AuxOut(3) Output eos;
    

    @Override
    public void init() \{
        video.linkAs(PResource::from, player::location);
        rate.link(player::rate);
        loop.valuesAs(PBoolean.class).link(b -> player.looping(b.value()));
        rewindAndPlay.link(() -> \{ 
            position = 0;
            seek();
            player.play();
        \});
        play.link(player::play);
        pause.link(player::pause);
        stop.link(player::stop);
        audioSink.linkAs(Value::toString, player::audioSink);
        player.onReady(ready::send);
        player.onError(msg -> \{
            log(ERROR, msg);
            error.send(msg);
        \});
        player.onEOS(eos::send);
    \}

    @Override
    public void draw() \{
        if (player.render(this::drawFrame)) \{
            position = player.position();
        \} else \{
            position = 0;
        \}
        state = player.state().toString();
    \}

    void drawFrame(PImage frame) \{
        double outWidth = zoom * frame.width;
        double outHeight = zoom * frame.height;
        if (resizeMode == ResizeMode.Stretch) \{
            outWidth *= (double) width / frame.width;
            outHeight *= (double) height / frame.height;
        \} else if (resizeMode == ResizeMode.Scale) \{
            double r = min((double) width / frame.width, (double) height / frame.height);
            outWidth *= r;
            outHeight *= r;
        \}
        image(frame, alignX * (width - outWidth),
                alignY * (height - outHeight),
                outWidth,
                outHeight);
    \}
    
    void seek() \{
        player.position(position);
    \}

"
        .video file:/home/anton/Videos/Hacksmith/Terribilis/TerribilisMain.mp4
        .zoom 1.061933405315502
      }
      @ ./colour-correction-1 video:gl:p2d {
        #%graph.x 685
        #%graph.y 163
        #%graph.comment \n
        .code "

    @In(1)
    PImage in;
    @P(-2)
    @Type.String(mime = GLSL_VERTEX_MIME, template = DEFAULT_VERTEX_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String vertex;
    @P(-1)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @P(2)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double contrast;
    @P(3)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double saturation;
    @P(4)
    @Type.Number(min = 0, max = 4, def = 1, skew=2)
    double brightness;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{

        if (shader == null) \{
            shader = createShader(
                    vertex.isEmpty() ? DEFAULT_VERTEX_SHADER : vertex,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        shader.set(\"RENDERSIZE\", width, height);
        updateUniforms();
        noStroke();
        beginShape(QUADS);
        vertex(0, 0, 0, 0);
        vertex(width, 0, 1, 0);
        vertex(width, height, 1, 1);
        vertex(0, height, 0, 1);
        endShape();
        resetShader();

    \}

    void updateUniforms() \{
        shader.set(\"inputImage\", in);
        shader.set(\"contrast\", contrast);
        shader.set(\"saturation\", saturation);
        shader.set(\"brightness\", brightness);
    \}

    void updateShader() \{
        shader = null;
    \}
"
        .vertex "uniform mat4 transformMatrix;
uniform mat4 inputImageMatrix;

attribute vec4 position;
attribute vec2 texCoord;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

void main() \{
  isf_FragNormCoord = texCoord;
  isf_FragCoord = position.xy;
  gl_Position = transformMatrix * position;
\}"
        .fragment "uniform sampler2D inputImage;
uniform mat4 inputImageMatrix;

uniform float contrast;
uniform float saturation;
uniform float brightness;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

vec3 rgb2hsv(vec3 c)	\{
	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
	vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
	
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
\}

vec3 hsv2rgb(vec3 c)	\{
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
\}

void main()
\{
	vec4 inColor = texture2D(inputImage, (inputImageMatrix * vec4(isf_FragNormCoord, 1.0, 1.0)).xy); 
	vec3 outColor = rgb2hsv(inColor.rgb);
        outColor.g *= saturation;
        outColor.rgb = hsv2rgb(outColor);
        outColor.rgb = outColor.rgb*contrast;
	outColor.rgb += vec3(brightness, brightness, brightness)-vec3(1,1,1);
	gl_FragColor.rgb = outColor.rgb;
        gl_FragColor.a = 1.0;
\}




"
        .contrast 2.079874126521357
        .saturation 0.0
        .brightness 0.648619431557137
      }
      @ ./colour-0 video:gl:p2d {
        #%graph.x 747
        #%graph.y 422
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -9989121
        .hex-rgb 6793FF
        .red 103.0
        .green 147.0
        .blue 255.0
        .hue 0.6190476190476191
        .saturation 0.5953757166862488
        .brightness 1.0
      }
      @ ./composite-0 video:composite {
        #%graph.x 1218
        #%graph.y 397
        .mix 0.36936936936936937
      }
      @ ./composite-1 video:composite {
        #%graph.x 1176
        #%graph.y 607
        .mode BitXor
        .mix 0.4144144144144144
      }
      @ ./colour-1 video:gl:p2d {
        #%graph.x 929
        #%graph.y 622
        .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
        .int-rgb -7710172
        .hex-rgb 8A5A24
        .red 138.0
        .green 90.0
        .blue 36.0
        .hue 0.08843537414965986
        .saturation 0.7414965986394558
        .brightness 0.54
      }
      @ ./start-trigger-1 core:start-trigger {
        #%graph.x 32
        #%graph.y 83
      }
      @ ./solarize video:gl:p2d {
        #%graph.x 517
        #%graph.y -63
        #%graph.comment Solarizes an image\nby VIDVOX\nCategories : Glitch
        .code "

    @In(1)
    PImage in;
    @P(-2)
    @Type.String(mime = GLSL_VERTEX_MIME, template = DEFAULT_VERTEX_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String vertex;
    @P(-1)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @P(1)
    @Type.Number(min = 0, max = 1, def = 0.5)
    double centerBrightness;
    @P(2)
    @Type.Number(min = 0, max = 4, def = 1)
    double powerCurve;
    @P(3)
    @Type.Number(min = 0, max = 1, def = 0)
    double colorize;
    @P(4)
    @Type.Boolean(def = false)
    boolean inverse;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{

        if (shader == null) \{
            shader = createShader(
                    vertex.isEmpty() ? DEFAULT_VERTEX_SHADER : vertex,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        shader.set(\"RENDERSIZE\", width, height);
        updateUniforms();
        noStroke();
        beginShape(QUADS);
        vertex(0, 0, 0, 0);
        vertex(width, 0, 1, 0);
        vertex(width, height, 1, 1);
        vertex(0, height, 0, 1);
        endShape();
        resetShader();

    \}

    void updateUniforms() \{
        shader.set(\"inputImage\", in);
        shader.set(\"centerBrightness\", centerBrightness);
        shader.set(\"powerCurve\", powerCurve);
        shader.set(\"colorize\", colorize);
        shader.set(\"inverse\", inverse);
    \}

    void updateShader() \{
        shader = null;
    \}
"
        .vertex "uniform mat4 transformMatrix;
uniform mat4 inputImageMatrix;

attribute vec4 position;
attribute vec2 texCoord;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

void main() \{
  isf_FragNormCoord = texCoord;
  isf_FragCoord = position.xy;
  gl_Position = transformMatrix * position;
\}"
        .fragment "uniform sampler2D inputImage;
uniform mat4 inputImageMatrix;

uniform float centerBrightness;
uniform float powerCurve;
uniform float colorize;
uniform bool inverse;

varying vec2 isf_FragNormCoord;
varying vec2 isf_FragCoord;

vec3 rgb2hsv(vec3 c)	\{
	vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
	vec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);
	vec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);
	
	float d = q.x - min(q.w, q.y);
	float e = 1.0e-10;
	return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
\}

vec3 hsv2rgb(vec3 c)	\{
	vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
	vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
	return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
\}




void main()
\{
	vec4		inColor = texture2D(inputImage, (inputImageMatrix * vec4(isf_FragNormCoord, 1.0, 1.0)).xy); 
	vec4		hslColor;
	vec4		outColor;
	
	//	convert to HSV
	hslColor.rgb = rgb2hsv(inColor.rgb);
	outColor.rgb = hslColor.rgb;
	outColor.a = inColor.a;
	
	//	drop the saturation
	//outColor.g = 0.0;
	
	//	adjust the brightness curve
	outColor.b = pow(outColor.b, powerCurve);
	outColor.b = (outColor.b < centerBrightness) ? (1.0 - outColor.b / centerBrightness) : (outColor.b - centerBrightness) / centerBrightness;
	outColor.b = (inverse) ? 1.0 - outColor.b : outColor.b;
	
	outColor.g = (inverse) ? outColor.g * (1.0-hslColor.b) * colorize : outColor.g * hslColor.b * colorize;
	
	//	convert back to rgb
	outColor.rgb = hsv2rgb(outColor.rgb);
	
	gl_FragColor = outColor;
\}




"
        .center-brightness 0.5666666666666667
        .power-curve 0.9333333333333333
      }
      ~ ./colour-0!out ./composite-0!src
      ~ ./colour-1!out ./composite-1!src
      ~ ./colour-correction-1!out ./composite-0!in
      ~ ./colour-correction-1!out ./composite-1!in
      ~ ./start-trigger-1!out ./player-buildings!rewind-and-play
      ~ ./player-buildings!out ./solarize!in
      ~ ./player-buildings!out ./colour-correction-1!in
    }
    @ ./ping-control core:custom {
      #%graph.x 21
      #%graph.y 15
      .code "

    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @P(13) @OnChange(\"onPingCombinedIn\") int pingCombinedIn;
    
    @T(10) void ping0RedIn() \{
        ping0Red.send();
    \}
    @T(11) void ping1YellowIn() \{
        ping1Yellow.send();
    \}
    @T(12) void ping2CyanIn() \{
        ping2Cyan.send();
    \}
    
    void onPingCombinedIn() \{
        if (0 == pingCombinedIn) \{ 
            ping0RedIn();
        \} else if (1 == pingCombinedIn) \{
            ping1YellowIn();
        \} else if (2 == pingCombinedIn) \{
            ping2CyanIn();
        \} else \{
            log(ERROR, \"Weird ping: \" + pingCombinedIn);
        \}
    \}
"
      .ping-combined-in 1
    }
    @ ./city video:gl:p2d {
      #%graph.x 396
      #%graph.y 29
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @P(11) @Type.Number(def=0.9, min=0, max=1) Property c1;
    @P(12) @Type.Number(def=0.1, min=0, max=1) Property c2;
    @P(13) @Type.Number(def=0.2, min=0, max=1) Property c3;
    

    @Inject Property shift;
    @Inject Property gamma;
    @Inject Property shuffler;
    @Inject Property shufflerIndex;
    double\[\] shufflers = \{ 0.34995, 0.35005, 0.35 \};
    
    @P(1) @Type.Number(min=0, max=2, def=0.4) double pushTime;
    @P(2) @Type.Number(min=0, max=2, def=0.2) double coloursTime;
    @P(3) @Type.Number(min=0, max=2, def=0.6) double shuffleTime;
    
    PShader shader;
    
    void updateUniforms() \{
        shader.set(\"time\", millis()/2000.0 + d(shift));
        shader.set(\"resolution\", width, height);
        shader.set(\"c1\", d(c1));
        shader.set(\"c2\", d(c2));
        shader.set(\"c3\", d(c3));
        shader.set(\"gmma\", d(gamma));
        shader.set(\"shuffle\", d(shuffler));
    \}
    
    @T(0) void push() \{
        if (!shift.isAnimating()) \{
            shift.to(d(shift) + random(1, 1.9)).in(pushTime).easing(Easing.quintOut);
        \}
    \}
    
    @T(1) void coloursRand() \{
        c1.to(Math.random()).in(coloursTime).easeOut();
        c2.to(Math.random()).in(coloursTime).easeOut();
        c3.to(Math.random()).in(coloursTime).easeOut();
    \}
    
    @T(2) void flash() \{
//        if(!gamma.isAnimating()) \{
            gamma.to(0.2).in(0.2).easing(Easing.quintOut).easing(Easing.quintOut).whenDone(p1 -> \{
                gamma.to(0.5).in(0.5).easing(Easing.quintOut);
            \});
//        \}
    \}
    
    @T(3) void shuffle() \{
        int newShuffler = i(shufflerIndex) + 1;
        if (newShuffler >= shufflers.length) \{
            newShuffler = 0;
        \}
        shufflerIndex.set(newShuffler);
        shuffler.to(shufflers\[newShuffler\]).in(shuffleTime).easing(Easing.quintOut).easing(Easing.quintOut);
    \}
    
    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
    
    @Override
    public void init() \{
        shift.set(0);
    \}
"
      .push-time 2.0
      .fragment "#ifdef GL_ES
precision mediump float;
#endif

uniform vec2 resolution;
uniform vec2 mouse;
uniform float time;
uniform float c1;
uniform float c2;
uniform float c3;
uniform float gmma;
uniform float shuffle;
uniform vec2 redCell = \{-1.0, -1.0\};

//------------------------------------------------------------------------
// Alien Voxel Landscape
// by @BradyInstead
//------------------------------------------------------------------------

// based on https://iquilezles.org/www/articles/voxellines/voxellines.htm

//------------------------------------------------------------------------
// Camera
//------------------------------------------------------------------------

void doCamera( out vec3 camPos, out vec3 camTar, in float time)
\{
    float zoom = 50.;
    vec3 initPos = vec3(zoom);
	camPos = initPos;
    camPos.z += time*16.; // movement
    camTar = camPos-initPos;
\}


//------------------------------------------------------------------------
// Background 
//------------------------------------------------------------------------

vec3 doBackground( void )
\{
    return vec3( 0.);
\}


//------------------------------------------------------------------------
// Shaping 
//------------------------------------------------------------------------

// p = positions
// h = dimensions of elongation
vec4 opElongate( in vec3 p, in vec3 h )
\{
    vec3 q = abs(p)-h;
    return vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0) );
\}

float opSmoothUnion( float d1, float d2, float k )
\{
	float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );
	return mix( d2, d1, h ) - k*h*(1.0-h);
\}


//------------------------------------------------------------------------
// Modelling 
//------------------------------------------------------------------------

float noise( vec3 P )
\{
    //  https://github.com/BrianSharpe/Wombat/blob/master/Value3D.glsl

    // establish our grid cell and unit position
    vec3 Pi = floor(P);
    vec3 Pf = P - Pi;
    vec3 Pf_min1 = Pf - 1.0;

    // clamp the domain
    Pi.xyz = Pi.xyz - floor(Pi.xyz * ( 1.0 / 69.0 )) * 69.0;
    vec3 Pi_inc1 = step( Pi, vec3( 69.0 - 1.5 ) ) * ( Pi + 1.0 );

    // calculate the hash
    vec4 Pt = vec4( Pi.xy, Pi_inc1.xy ) + vec2( 50.0, 161.0 ).xyxy;
    Pt *= Pt;
    Pt = Pt.xzxz * Pt.yyww;
    vec2 hash_mod = vec2( 1.0 / ( 635.298681 + vec2( Pi.z, Pi_inc1.z ) * 48.500388 ) );
    vec4 hash_lowz = fract( Pt * hash_mod.xxxx );
    vec4 hash_highz = fract( Pt * hash_mod.yyyy );

    //	blend the results and return
    vec3 blend = Pf * Pf * Pf * (Pf * (Pf * 6.0 - 15.0) + 10.0);
    vec4 res0 = mix( hash_lowz, hash_highz, blend.z );
    vec4 blend2 = vec4( blend.xy, vec2( 1.0 - blend.xy ) );
    return dot( res0, blend2.zxzx * blend2.wwyy );
\}

float mapTerrain( vec3 p )
\{
    //p*=0.35;
    p*=shuffle;
    p.y /= 2.;
	return noise(p);
\}

float map(in vec3 p)
\{
	float terrain = mapTerrain( p ) + 0.12*p.y;
	return step( terrain, 0.95 );
\}


//------------------------------------------------------------------------
// Material
//------------------------------------------------------------------------

vec3 doMaterial( vec3 pos, vec3 vos )
\{
    float h = vos.y/8.;
    
    // vec3 primary = vec3(.9, .1, .2) ;
    vec3 primary = vec3(c1, c2, c3) ;
vec3 secondary = vec3(1-c1, 1-c2, 1-c3);
    //vec3 secondary = vec3(.1, .5, 1.);
    
    return mix(primary, secondary, h)*h;
\}

vec3 saturation(vec3 rgb, float adjustment)
\{
    // Algorithm from Chapter 16 of OpenGL Shading Language
    const vec3 W = vec3(0.2125, 0.7154, 0.0721);
    vec3 intensity = vec3(dot(rgb, W));
    return mix(intensity, rgb, adjustment);
\}

float maxcomp( in vec4 v )
\{
    return max( max(v.x,v.y), max(v.z,v.w) );
\}

float isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )
\{
    vec2 st = 1.0 - uv;

    // edges
    vec4 wb = smoothstep( 0.7, 0.99, vec4(uv.x,
                                           st.x,
                                           uv.y,
                                           st.y) ) * ( 1.0 - va + va*vc );
    // corners
    vec4 wc = smoothstep( 0.7, 0.99, vec4(uv.x*uv.y,
                                           st.x*uv.y,
                                           st.x*st.y,
                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );
    return 1.0 - maxcomp( max(wb,wc) );
\}

float calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )
\{
    vec2 st = 1.0 - uv;

    // edges
    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;

    // corners
    vec4 wb = vec4(uv.x*uv.y,
                   st.x*uv.y,
                   st.x*st.y,
                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);
    
    return wa.x + wa.y + wa.z + wa.w +
           wb.x + wb.y + wb.z + wb.w;
\}

vec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal , vec3 vos, vec3 dir)
\{
    vec3 uvw = pos - vos;
    
    vec3 v1  = vos + nor + dir.yzx;
	vec3 v2  = vos + nor - dir.yzx;
	vec3 v3  = vos + nor + dir.zxy;
	vec3 v4  = vos + nor - dir.zxy;
	vec3 v5  = vos + nor + dir.yzx + dir.zxy;
    vec3 v6  = vos + nor - dir.yzx + dir.zxy;
	vec3 v7  = vos + nor - dir.yzx - dir.zxy;
	vec3 v8  = vos + nor + dir.yzx - dir.zxy;
	vec3 v9  = vos + dir.yzx;
	vec3 v10 = vos - dir.yzx;
	vec3 v11 = vos + dir.zxy;
	vec3 v12 = vos - dir.zxy;
 	vec3 v13 = vos + dir.yzx + dir.zxy; 
	vec3 v14 = vos - dir.yzx + dir.zxy;
	vec3 v15 = vos - dir.yzx - dir.zxy;
	vec3 v16 = vos + dir.yzx - dir.zxy;

	vec4 vc = vec4( map(v1),  map(v2),  map(v3),  map(v4)  );
	vec4 vd = vec4( map(v5),  map(v6),  map(v7),  map(v8)  );
	vec4 va = vec4( map(v9),  map(v10), map(v11), map(v12) );
	vec4 vb = vec4( map(v13), map(v14), map(v15), map(v16) );
		
	vec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );
    
    // ambient occlusion
    float occ = 1.0;
    occ = calcOcc( uv, va, vb, vc, vd );
    float ocAm = 3.0;
    occ = 1.0 - occ/ocAm;
    occ = pow(occ, 5.);
    
    // fake lighting
    vec3 norC = abs(nor);
    float sum = min(1.0, norC.g + norC.r*.35 + norC.b*.2 + .05);
    vec3 col = mal*sum*isEdge(uv, va, vb, vc, vd);
    
    col = mix(col.rgb*occ, vec3(col.rg*occ, col.b), .2);
    
    return col;
\}


//------------------------------------------------------------------------
// Raymarching
//------------------------------------------------------------------------

float calcIntersection( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir, out int mat )
\{
	vec3 pos = floor(ro);
	vec3 ri = 1.0/rd;
	vec3 rs = sign(rd);
	vec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;
	
	float res = -1.0;
	vec3 mm = vec3(0.0);
	for( int i=0; i<200; i++ ) 
	\{
		if( map(pos)>0.5 ) \{ res=1.0; break; \}
		mm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);
		dis += mm * rs * ri;
        pos += mm * rs;
	\}

	vec3 nor = -mm*rs;
	vec3 vos = pos;
	
    // intersect the cube	
	vec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;
	float t = max ( mini.x, max ( mini.y, mini.z ) );
	
	oDir = mm;
	oVos = vos;

	return t*res;
\}

//------------------------------------------------------------------------
// Main
//------------------------------------------------------------------------

mat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )
\{
    vec3 ww = normalize( ta - ro );
    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );
    vec3 vv = normalize( cross(uu,ww));
    return mat3( uu, vv, ww );
\}

void main()
\{   
    vec2 p = (-resolution.xy + 2.0*gl_FragCoord.xy)/resolution.y;
    p.x /= 1.25;

    //-----------------------------------------------------
    // camera
    //-----------------------------------------------------
    
    // camera movement
    vec3 ro, ta;
    doCamera( ro, ta, time);

    // camera matrix
    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll
    
	// create view ray
	vec3 rd = normalize( vec3(p.xy,1.0) ); // lens length
    rd.y -= 1.0;

    //-----------------------------------------------------
	// render
    //-----------------------------------------------------

	vec3 col = doBackground();

	// raymarch
    vec3 vos, dir;
    int mat;
    float t = calcIntersection( ro, rd, vos, dir, mat );
    if( t>0.0 )
    \{
        // geometry
        vec3 pos = ro + t*rd;
        vec3 nor = -dir*sign(rd);

        // materials
        vec3 mal = doMaterial( pos, vos );

        col = doLighting( pos, nor, rd, t, mal, vos, dir);
	\}

    
    col *= 1.5;
    col -= .03;
    
	//-----------------------------------------------------
	// postprocessing
    //-----------------------------------------------------
    // gamma
	col = pow( clamp(col,0.0,1.0), vec3(gmma) );
    
    // saturation
	col = saturation(col, 2.0);   
    
    gl_FragColor = vec4( col, 1.0 );
\}"
      .c-1 0.7380869577367023
      .c-2 0.7637352011832953
      .c-3 0.3561964751321113
    }
    @ ./lines video:gl:p2d {
      #%graph.x 529
      #%graph.y 254
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property timer;
    double angle;

    void updateUniforms() \{
        shader.set(\"resolution\", width, height);
        shader.set(\"position\", d(timer));
        shader.set(\"angle\", angle);
    \}
    
    @T(1) void animate() \{
        timer.set(0);
        timer.to(1).in(0.5).linear();
        //timer.animator().whenDone(p -> animate());
        angle = random(-PI, PI);
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
        //animate();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "#ifdef GL_ES
precision mediump float;
#endif

#define PI 3.14159265359

uniform vec2 resolution;
uniform vec2 mouse;
uniform float position;
uniform float angle;

float random (float seed) \{
    return fract(sin(dot(vec2(seed, 1.0),
                         vec2(12.9898,78.233)))*
        43758.5453123);
\}

float plot(vec2 st, float pct)\{
  return  smoothstep( pct-0.02, pct, st.y) -
          smoothstep( pct, pct+0.02, st.y);
\}

//  Function from IÃ±igo Quiles
//  www.iquilezles.org/www/articles/functions/functions.htm
float cubicPulse( float c, float w, float x )\{
    x = abs(x - c);
    if( x>w ) return 0.0;
    x /= w;
    return 1.0 - x*x*(3.0-2.0*x);
\}

mat2 rotate2d(float _angle)\{
    return mat2(cos(_angle),-sin(_angle),
                sin(_angle),cos(_angle));
\}

void main() \{
    if(1 == position) \{
        gl_FragColor = vec4(0.0, 0.0, 0.0,1.0);
        return;
    \}

    vec2 st = gl_FragCoord.xy/max(resolution.x, resolution.y);
    st -= vec2(0.5);
    st *= rotate2d(angle);
    st += vec2(0.5);

    // Smooth interpolation between 0.1 and 0.9
    float y = cubicPulse(0.5,0.2,(st.x+position*1.2-0.5));
    vec3 color = vec3(y);

    float pct = 0; //plot(st,y);
    color = (1.0-pct)*color+pct*vec3(0.0,1.0,0.0);

    gl_FragColor = vec4(color,1.0);
\}
"
    }
    @ ./control core:custom {
      #%graph.x 354
      #%graph.y 538
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.oneByOne;
    final double MOVEMENT_SPEED = 35;
    final double TIME_TO_MOVE = 1;
    final int MOVE_TO_CENTRE = 0;
    final int CELLS_COUNT = 8;
    final double TRANSITION_TIME = 10;


    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(1)
    void cityBuildings() \{
        activate();
    \}

    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @AuxOut(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @AuxOut(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x 639
      #%graph.y 763
      .address /video/x-fader.to-city-buildings
    }
    @ ./properties-out core:routing:send {
      #%graph.x 640
      #%graph.y 665
      .address /video/voronoi-generator.properties-in
    }
    @ ./composite-0 video:composite {
      #%graph.x 784
      #%graph.y -98
      .mix 0.2619047619047619
    }
    @ ./strobe-1 video:gl:p2d {
      #%graph.x 784
      #%graph.y 452
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-2 video:gl:p2d {
      #%graph.x 765
      #%graph.y 189
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    ~ ./ping-control!ping-2-cyan ./city!colours-rand
    ~ ./ping-control!ping-1-yellow ./city!flash
    ~ ./lines!out ./voronoi-renderer!in-edges
    ~ ./ping-control!ping-2-cyan ./lines!animate
    ~ ./control!properties-out ./properties-out!in
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./city!out ./composite-0!src
    ~ ./composite-0!out ./voronoi-renderer!in-3
    ~ ./movies!out ./composite-0!in
    ~ ./ping-control!ping-0-red ./city!push
    ~ ./composite-0!out ./voronoi-renderer!in-2
    ~ ./strobe-1!out ./voronoi-renderer!in-1
    ~ ./ping-control!ping-2-cyan ./strobe-1!strobe
    ~ ./ping-control!ping-0-red ./strobe-2!strobe
    ~ ./strobe-2!out ./voronoi-renderer!in-5
    ~ ./movies!out ./voronoi-renderer!in-5
    ~ ./movies!out ./voronoi-renderer!in-6
    ~ ./movies!composite-0-out ./voronoi-renderer!in-0
    ~ ./movies!composite-1-out ./voronoi-renderer!in-4
  }
  @ ./bubbles core:container {
    #%graph.x 954
    #%graph.y 828
    #%praxis.version 4.4.0
    .ports "voronoi-pipe-in \"voronoi-renderer1!voronoi-pipe-in\" out \"voronoi-renderer1!out\""
    @ ./ping-control core:custom {
      #%graph.x -1629
      #%graph.y -598
      .code "

    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @P(13) @OnChange(\"onPingCombinedIn\") int pingCombinedIn;
    
    @T(10) void ping0RedIn() \{
        ping0Red.send();
    \}
    @T(11) void ping1YellowIn() \{
        ping1Yellow.send();
    \}
    @T(12) void ping2CyanIn() \{
        ping2Cyan.send();
    \}
    
    void onPingCombinedIn() \{
        if (0 == pingCombinedIn) \{ 
            ping0RedIn();
        \} else if (1 == pingCombinedIn) \{
            ping1YellowIn();
        \} else if (2 == pingCombinedIn) \{
            ping2CyanIn();
        \} else \{
            log(ERROR, \"Weird ping: \" + pingCombinedIn);
        \}
    \}
"
      .ping-combined-in 1
    }
    @ ./strobe-0 video:gl:p2d {
      #%graph.x -1211
      #%graph.y -315
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 246.5
      .hue 0.1666666716337204
      .saturation 0.03529411926865578
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-1 video:gl:p2d {
      #%graph.x -1426
      #%graph.y -548
      #%graph.minimized true
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-2 video:gl:p2d {
      #%graph.x -1399
      #%graph.y -398
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 18.7
      .blue 30.599999999999998
      .hue 0.9915611743927002
      .saturation 0.929411768913269
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./bubbles video:gl:p2d {
      #%graph.x -941
      #%graph.y -648
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @Inject Property shift;
    @Inject Property shake;
    @Inject Property colour;
    
    @P(1) @Type.Number(min=0, max=2, def=0.4) double tideTime;
    @P(2) @Type.Number(min=0, max=2, def=0.2) double shakeTime;
    @P(3) @Type.Number(min=0, max=2, def=0.2) double colourTime;
    @P(4) @Type.Number(skew = 4, min=0.1, max=100, def=1) double speed;
    
    PShader shader;
    
    void updateUniforms() \{
        shader.set(\"time\", millis()*speed/1000.1);
        shader.set(\"shift\", d(shift)*speed);
        shader.set(\"shake\", d(shake));
        shader.set(\"col\", d(colour));
        shader.set(\"resolution\", width, height);
    \}
    
    @T(0) void rise() \{
        shift.to(d(shift) + random(3, 10)).in(tideTime).easing(Easing.cubicOut);
    \}
    
    @T(1) void shakeIt() \{
        shake.to(random(0.94, 1.06)).in(shakeTime).easing(Easing.cubicInOut).whenDone(p1 -> \{
            shake.to(1).in(shakeTime).easing(Easing.cubicInOut);
        \});
    \}
    
    @T(2) void flash() \{
        colour.to(0.1).in(colourTime).easing(Easing.cubicInOut).whenDone(p1 -> \{
            colour.to(1).in(colourTime).easing(Easing.cubicInOut);
        \});
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}
    
    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .tide-time 0.8
      .shake-time 0.3
      .colour-time 0.1
      .speed 8.328077981830486
      .fragment "uniform vec2 resolution;
uniform float time;
uniform float shift;
uniform float shake;
uniform float col;

//Calculate the squared length of a vector
float length2(vec2 p)\{
    return dot(p,p);
\}

//Generate some noise to scatter points.
float noise(vec2 p)\{
	return fract(sin(fract(sin(p.x) * (43.13311)) + p.y) * 31.0011);
\}

float worley(vec2 p) \{
    //Set our distance to infinity
	float d = 1e30;
    //For the 9 surrounding grid points
	for (int xo = -1; xo <= 1; ++xo) \{
		for (int yo = -1; yo <= 1; ++yo) \{
            //Floor our vec2 and add an offset to create our point
			vec2 tp = floor(p) + vec2(xo, yo);
            //Calculate the minimum distance for this grid point
            //Mix in the noise value too!
			d = min(d, length2(p - tp - noise(tp)));
		\}
	\}
	return 3.0*exp(-4.0*abs(2.5*d - 1.0));
\}

float fworley(vec2 p) \{
    float position = time + shift;
    //Stack noise layers 
	return sqrt(sqrt(sqrt(
		worley(p*5.0 + 0.05*time) *
		sqrt(worley(p * 50.0 + 0.12 + -0.1*position)) *
		sqrt(sqrt(worley(p * -10.0 + 0.03*position))))));
\}
      
void main()
\{
	vec2 uv = gl_FragCoord.xy / resolution.xy;
    //Calculate an intensity
    float t = fworley(uv * resolution.xy / (shake*1600.0));
    //Add some gradient
    t*=exp(-length2(abs(0.7*uv - 1.0)));	
    //Make it blue!
//    gl_FragColor = vec4(t * vec3(0.1, 1.1*t, pow(t, (col*0.5)-t)), 1.0);
    gl_FragColor = vec4(t * vec3(pow(t, (col*0.6)-t), 1.4*t, 0.1), 1.0);

\}

"
    }
    @ ./start-trigger-1 core:start-trigger {
      #%graph.x -1377
      #%graph.y -648
    }
    @ ./voronoi-renderer1 video:gl:p2d {
      #%graph.x -279
      #%graph.y -466
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 7
      .edge-width 27.349809382716053
      .draw-cells true
      .just-colours false
    }
    @ ./composite-0 video:composite {
      #%graph.x -674
      #%graph.y -191
      .mode BitXor
      .mix 0.5247524752475248
    }
    @ ./colour-0 video:gl:p2d {
      #%graph.x -1046
      #%graph.y -231
      .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
      .int-rgb -11139426
      .hex-rgb 56069E
      .red 86.7
      .green 6.0
      .blue 158.1
      .hue 0.7543859481811523
      .saturation 0.9620253443717957
      .brightness 0.6196078658103943
    }
    @ ./control core:custom {
      #%graph.x -1544
      #%graph.y -84
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.randomly;
    final double MOVEMENT_SPEED = 28;
    final double TIME_TO_MOVE = 0.2;
    final int MOVE_TO_CENTRE = 0;
    final int CELLS_COUNT = 9;
    final double TRANSITION_TIME = 10;


    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(1)
    void bubbles() \{
        activate();
    \}

    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @AuxOut(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @AuxOut(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x -1259
      #%graph.y 141
      .address /video/x-fader.to-bubbles
    }
    @ ./properties-out core:routing:send {
      #%graph.x -1258
      #%graph.y 43
      .address /video/voronoi-generator.properties-in
    }
    ~ ./ping-control!ping-1-yellow ./strobe-0!strobe
    ~ ./ping-control!ping-1-yellow ./bubbles!flash
    ~ ./ping-control!ping-0-red ./bubbles!rise
    ~ ./ping-control!ping-1-yellow ./bubbles!shake-it
    ~ ./start-trigger-1!out ./bubbles!rise
    ~ ./start-trigger-1!out ./bubbles!shake-it
    ~ ./start-trigger-1!out ./bubbles!flash
    ~ ./strobe-1!out ./voronoi-renderer1!in-0
    ~ ./strobe-1!out ./voronoi-renderer1!in-1
    ~ ./strobe-0!out ./voronoi-renderer1!in-edges
    ~ ./strobe-2!out ./voronoi-renderer1!in-2
    ~ ./bubbles!out ./voronoi-renderer1!in-1
    ~ ./bubbles!out ./voronoi-renderer1!in-2
    ~ ./bubbles!out ./voronoi-renderer1!in-5
    ~ ./bubbles!out ./voronoi-renderer1!in-6
    ~ ./colour-0!out ./composite-0!src
    ~ ./bubbles!out ./composite-0!in
    ~ ./bubbles!out ./voronoi-renderer1!in-0
    ~ ./composite-0!out ./voronoi-renderer1!in-3
    ~ ./composite-0!out ./voronoi-renderer1!in-4
    ~ ./control!properties-out ./properties-out!in
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./ping-control!ping-2-cyan ./strobe-2!strobe
    ~ ./ping-control!ping-0-red ./strobe-1!strobe
  }
  @ ./titles core:container {
    #%graph.x 1785
    #%graph.y 135
    #%praxis.version 4.4.0
    .ports "out \"logo-image!out\" mix \"titles!mix\" title \"titles!title\""
    @ ./logo-image video:still {
      #%graph.x 1112
      #%graph.y 135
      .code "

    enum ResizeMode \{Stretch, Scale, Crop\};
    
    @In(1) PImage in;
    
    @P(1) @OnChange(\"imageChanged\") @OnError(\"imageError\")
    PImage image;
    @P(2)
    ResizeMode resizeMode;
    @P(3) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignX;
    @P(4) @Type.Number(min = 0, max = 1, def = 0.5)
    double alignY;
    @P(5) @Type.Number(min = 0, max = 8, def = 1, skew = 4)
    double zoom;
    
    @AuxOut(1) Output ready;
    @AuxOut(2) Output error;
    
    @P(100) @ReadOnly @Type.Number(min = 0, max = 1, def = 0) Property opacity;
    @P(101) @Type.Number(min = 0, max = 10, def = 4) double transitionTime;
    
    @T(0)
    public void reset() \{
        opacity.set(0);
    \}
    
    @T(1)
    public void activate() \{
        opacity.set(0).to(1).easeIn().in(transitionTime).whenDone(p1 -> \{
            opacity.set(1).to(0.9).easeIn().in(transitionTime/2).whenDone(p2 -> \{
                opacity.set(0.9).to(0).easeIn().in(transitionTime/2).whenDone(p3 -> \{
                    p3.set(0);
                \});
            \});
        \});
    \}
    
    
    @Override
    public void draw() \{
        copy(in);
        release(in);
        if (image != null) \{
            draw(image);
        \}
    \}
    
    void draw(PImage image) \{
        double outWidth = zoom * image.width;
        double outHeight = zoom * image.height;
        if (resizeMode == ResizeMode.Stretch) \{
            outWidth *= (double) width / image.width;
            outHeight *= (double) height / image.height;
        \} else if (resizeMode == ResizeMode.Scale) \{
            double r = min((double) width / image.width, (double) height / image.height);
            outWidth *= r;
            outHeight *= r;
        \}
        image(image, alignX * (width - outWidth),
                alignY * (height - outHeight),
                outWidth,
                outHeight);
        blendMode(ADD, d(opacity));
    \}
    
    void imageChanged() \{
        ready.send();
    \}
    
    void imageError() \{
        error.send();
    \}
    
"
      .resize-mode Scale
      .zoom 0.8179886567486027
    }
    @ ./titles video:gl:p2d {
      #%graph.x 865
      #%graph.y 85
      .code "

    @P(1) @Config.Port(false) PFont font;
    @P(3) @Config.Port(false) @Type.Integer(min=1,max=256,def=200) int fontSize;
    @P(4) @Type.Number(min=0, max=1, def=0.5) double alignX;
    @P(5) @Type.Number(min=0, max=1, def=0.5) double alignY;
    
    @P(30) @ReadOnly @Transient @Type.Number(min=0, max=255, def=0) Property titlesTimer;
    @P(31) @ReadOnly @Transient Property mixTimer;
    @Out(100) Output logoReset;
    @Out(101) Output logoStart;
    @Out(10) Output mix;
    
    @P(10) @OnChange(\"titleAndLogo\") String title;

    @T(0)    
    public void reset() \{
        logoReset.send();
        titlesTimer.set(0);
    \}

    public void titleAndLogo() \{
        if (null == title || title.length() == 0) \{
            return;
        \}
        reset();
        if (title.equals(\" \")) \{
            mixTimer.set(1).to(0.2).in(2).easeIn().whenDone(p -> \{
                mixTimer.set(0.2).to(0.51).in(6).easeInOut().whenDone(p1 -> \{
                    mixTimer.set(0.51).to(1).in(2).easeIn().whenDone(p2 -> \{
                        p2.set(1);
                    \});
                \});
            \});
            logoStart.send();
        \} else \{
            mixTimer.set(1).to(0.2).in(2).easeIn().whenDone(p -> \{
                mixTimer.set(0.2).to(0.51).in(10).easeInOut().whenDone(p1 -> \{
                    mixTimer.set(0.51).to(1).in(2).easeIn().whenDone(p2 -> \{
                        p2.set(1);
                    \});
                \});
            \});
            titlesTimer.set(0).to(2300).in(50).whenDone(p -> \{
                titlesTimer.set(400).to(0).in(2).easeOut().whenDone(p2 -> \{
                    p2.set(0);
                    title = null;
                    logoStart.send();
                \});
            \});
        \}
    \}
    
    @Override
    public void draw() \{
        if (null != title && title.length() != 0) \{
            textFont(font, fontSize);
            fill(min(255, i(titlesTimer)));
            double textHeight = textAscent() + textDescent();
            text(title, width*alignX - textWidth(title)*alignX, alignY*(height-textHeight) + textAscent());
        \}
        mix.send(d(mixTimer));
    \}
"
      .font [file "resources/Apex Mk3-Medium.otf"]
      .title null
    }
    ~ ./titles!out ./logo-image!in
    ~ ./titles!logo-reset ./logo-image!reset
    ~ ./titles!logo-start ./logo-image!activate
  }
  @ ./composite-0 video:composite {
    #%graph.x 1858
    #%graph.y 370
    .mix 0
  }
  @ ./logo-trigger core:custom {
    #%graph.x 1335
    #%graph.y -51
    .code "

    @Out(10) Output title;
    
    
    @Override
    public void init() \{

    \}
    
    @T(5) void hybrid() \{
        title.send(\"PraxisLIVE\");
    \}
    
    @T(10) void noJoeHerrick() \{
        title.send(\"HACKSMITHS\");
    \}
    
    @T(11) void djGrapefruit() \{
        title.send(\"DJ GRAPEFRUIT\");
    \}
    
    @T(12) void djSovnet() \{
        title.send(\"DJ SOVNET\");
    \}
    
    @T(13) void terribilis() \{
        title.send(\"Terribilis\");
    \}
    
    @T(14) void acell() \{
        title.send(\"ACELL\");
    \}
    
    @T(15) void japhy() \{
        title.send(\"JAPHY\");
    \}
    
    @T(16) void tzt() \{
        title.send(\"TZT\");
    \}
    
    @T(17) void jamesWvr() \{
        title.send(\"JAMES WVR\");
    \}
    
    @T(18) void eyeMeasure() \{
        title.send(\"EYEMEASURE\");
    \}

    
    @Override
    public void update() \{

    \}
    
"
  }
  @ ./experiment core:container {
    #%graph.x 946
    #%graph.y 941
    #%praxis.version 4.4.0
    .ports "voronoi-pipe-in \"voronoi-renderer1!voronoi-pipe-in\" out \"voronoi-renderer1!out\""
    @ ./ping-control core:custom {
      #%graph.x -1629
      #%graph.y -598
      .code "

    @AuxOut(20) Output ping0Red;
    @AuxOut(21) Output ping1Yellow;
    @AuxOut(22) Output ping2Cyan;
    @P(13) @OnChange(\"onPingCombinedIn\") int pingCombinedIn;
    
    @T(10) void ping0RedIn() \{
        ping0Red.send();
    \}
    @T(11) void ping1YellowIn() \{
        ping1Yellow.send();
    \}
    @T(12) void ping2CyanIn() \{
        ping2Cyan.send();
    \}
    
    void onPingCombinedIn() \{
        if (0 == pingCombinedIn) \{ 
            ping0RedIn();
        \} else if (1 == pingCombinedIn) \{
            ping1YellowIn();
        \} else if (2 == pingCombinedIn) \{
            ping2CyanIn();
        \} else \{
            log(ERROR, \"Weird ping: \" + pingCombinedIn);
        \}
    \}
"
      .ping-combined-in 1
    }
    @ ./strobe-0 video:gl:p2d {
      #%graph.x -1299
      #%graph.y -289
      #%graph.minimized true
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-1 video:gl:p2d {
      #%graph.x -1299
      #%graph.y -340
      #%graph.minimized true
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./strobe-2 video:gl:p2d {
      #%graph.x -1300
      #%graph.y -230
      .code "import java.awt.Color;

    @P(0) @Type.Number(min = 0, max = 1) double ease;
    @P(1) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double red;
    @P(2) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double green;
    @P(3) @Type.Number(min = 0, max = 255) @OnChange(\"onRGB\") double blue;
    @P(4) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double hue;
    @P(5) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double saturation;
    @P(6) @Type.Number(min = 0, max = 1) @OnChange(\"onHSV\") double brightness;
    
    @Out(1) Output rgb;

    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;
    
    @Inject Property strobeBrightness;

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        shader.set(\"brightness\", d(strobeBrightness));
        shader.set(\"colour\", red, green, blue);
        rect(0, 0, width, height);
        resetShader();
    \}
    
    @T(0) void strobe() \{
        strobeBrightness.set(1);
        strobeBrightness.to(0).in(ease).easing(Easing.cubicIn);
    \}

    void updateShader() \{
        shader = null;
    \}

    void onRGB() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
        sendRGB();
    \}

    void onHSV() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        sendRGB();
    \}
    
    void sendRGB() \{
        // https://stackoverflow.com/a/17946089
        int rgbaInt = (round(red) << 24)
                + (round(green) << 16)
                + (round(blue) << 8);
        rgb.send(rgbaInt);
    \}
"
      .ease 0.2
      .red 255.0
      .green 255.0
      .blue 255.0
      .brightness 1.0
      .fragment "uniform vec3 colour;
uniform float brightness;

void main() \{
    gl_FragColor = vec4(
        colour.x/255*brightness,
        colour.y/255*brightness, 
        colour.z/255*brightness, 
        1.0
    );
\}"
    }
    @ ./start-trigger-1 core:start-trigger {
      #%graph.x -1377
      #%graph.y -648
    }
    @ ./voronoi-renderer1 video:gl:p2d {
      #%graph.x -278
      #%graph.y -466
      .code "import org.locationtech.jts.geom.*;
import java.io.DataInputStream;
import java.io.IOException;

    static final int MAX_CELLS_COUNT = 80;
    static final double EDGE_THRESHOLD = 0.1;
    static final String LAST_INPUT = \"Input per cell, last to the rest\";
    static final String CYCLE = \"Cycle inputs over cells\";
    
    @In(0) PImage in0; @In(1) PImage in1; @In(2) PImage in2; @In(3) PImage in3;
    @In(4) PImage in4; @In(5) PImage in5; @In(6) PImage in6;
    @In(7) PImage inEdges;
    
    @P(11) @Type.Integer(def = 6, min = 1, max = 7) int cellsInputs;
    @P(12) @Type.String(allowed = \{CYCLE, LAST_INPUT\}) String inputsToCells;
    
    @P(15) @Type.Number(def = 3, min = 0, max = 1000, skew=4) 
    @OnChange(\"updateCellsFromRawGeometry\") double edgeWidth;
    
    @P(17) @Type.Boolean(def = false) boolean drawCells;
    @P(18) @Type.Boolean(def = false) boolean drawCenters;
    @P(19) @Type.Boolean(def = true) boolean justColours;

    @AuxIn(100) Data.In<PBytes> voronoiPipeIn;
    @Inject Data.Sink<PBytes> voronoiSink;

    @AuxIn(101) Input voronoiIn;
    
    @OffScreen(persistent = false) PGraphics2D outEdges;
    @Inject Ref<List<PVector>> coloursRef;
    
    GeometryFactory geometryFactory = new GeometryFactory();

    RawGeometry rawGeometry = new RawGeometry();
    List<Cell> cells = Collections.emptyList();
    
    // Initialisation

    @Override public void setup() \{
        Data.link(voronoiPipeIn, voronoiSink.input());
        voronoiIn.valuesAs(PBytes.class).link(this::decodeVoronoiData);
        coloursRef.init(ArrayList::new);
        coloursRef.apply(list -> \{
            while(list.size() < MAX_CELLS_COUNT) \{
                list.add(new PVector(random(255), random(255), random(255)));
            \}
        \});
        noStroke();
    \}
    
    
    // Drawing
    
    @Override public void draw() \{
        decodeVoronoiData(voronoiSink.process(PBytes.EMPTY));
        
        if(edgeWidth > EDGE_THRESHOLD) \{
            drawEdges();
        \}
        if(drawCells) \{
            drawCells();
        \}
        if(drawCenters) \{
            drawCenters();
        \}
    \}
    
    void drawCells() \{
        cells.forEach(cell -> \{
            blendMode(BLEND);
            beginShape();
            if (justColours) \{
                PVector c = cell.colour();
                fill(c.x, c.y, c.z);
            \} else \{
                texture(cell.in());
            \}
            cell.polygon.forEach(v -> vertex(v.x, v.y, v.x, v.y));
            endShape(CLOSE);
        \});
    \}
    
    void drawCenters() \{
        blendMode(BLEND);
        textSize(10);
        fill(255);
        for(int i=0; i<cells.size(); ++i) \{
            text(i, cells.get(i).centre.x, cells.get(i).centre.y);
        \}
    \}
    
    void drawEdges() \{
// For unknown reason below doesn't work            
//            blendMode(BLEND);
//            beginShape();
//            if (justColours) \{
//                fill(255);
//            \} else \{
//                texture(inEdges);
//            \}
//            beginShape();
//            vertex(0, 0, 0, 0);
//            vertex(width, 0, width, 0);
//            vertex(width, height, width, height);
//            vertex(0, height, 0, height);
//            endShape(CLOSE);

        outEdges.beginDraw();
        outEdges.blendMode(REPLACE);
        outEdges.strokeWeight(edgeWidth);
        outEdges.fill(255);
        outEdges.noStroke();
        outEdges.rect(0, 0, width, height);

        if (!justColours) \{
            outEdges.blendMode(MULTIPLY);
            outEdges.image(inEdges, 0, 0);
        \}
        outEdges.endDraw();
        blendMode(ADD);
        image(outEdges, 0, 0);
    \}
   
    
    
    // Decode, and transform voronoi data
    
    
    
    
    void decodeVoronoiData(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available()>0) \{
                int cellsCount = dis.readInt();
                List<PVector> centres = new ArrayList<>();
                List<List<PVector>> polygons = new ArrayList<>();
                for (int i=0; i<cellsCount; ++i) \{
                    centres.add(new PVector(dis.readDouble(), dis.readDouble()));
                    int verticesCount = dis.readInt();
                    List<PVector> polygon = new ArrayList<>();
                    for (int j=0; j<verticesCount; ++j) \{
                        polygon.add(new PVector(dis.readDouble(), dis.readDouble()));
                    \}
                    polygons.add(polygon);
                \}
                dis.close();

                rawGeometry = new RawGeometry(centres, polygons);
                updateCellsFromRawGeometry();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Voronoi data decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
        
    void updateCellsFromRawGeometry() \{
        List<Cell> cells = new ArrayList<>();
        for(int i=0; i<rawGeometry.centres.size(); ++i) \{
            List<PVector> polygon = rawGeometry.polygons.get(i);
            if (null == polygon || polygon.isEmpty()) \{
                log(WARNING, \"Received polygon with no vertices. Cell no \" + i);
            \} else \{
                cells.add(new Cell(
                        i, 
                        rawGeometry.centres.get(i), 
                        offsetPolygon(i, polygon)));
            \}
        \}
        this.cells = cells;
    \}
    
    List<PVector> offsetPolygon(int cellNo, List<PVector> polygon) \{
        if (edgeWidth < EDGE_THRESHOLD) \{
            return polygon;
        \}
        
        List<PVector> originalVertices = new ArrayList<>(polygon);
        // close polygon - jts requirement
        originalVertices.add(originalVertices.get(0));
        
        Coordinate\[\] coordinates = originalVertices.stream()
                .map(v -> new Coordinate(v.x, v.y))
                .collect(Collectors.toList())
                .toArray(new Coordinate\[0\]);
        Polygon jtsPolygon = geometryFactory.createPolygon(coordinates); 
        Geometry geometry = jtsPolygon.buffer(-edgeWidth/2);
        Coordinate\[\] innerCoordinates = geometry.getBoundary().getCoordinates();
        return Arrays.asList(innerCoordinates)
                .subList(0, max(0, innerCoordinates.length-1))
                .stream()
                .map(c -> new PVector(c.x, c.y))
                .collect(Collectors.toList());
    \}


    
    // Cell container

    class Cell \{
        final int no;
        final PVector centre;
        final List<PVector> polygon;

        public Cell(int no, PVector centre, List<PVector> polygon) \{
            this.no = no;
            this.centre = centre;
            this.polygon = polygon;
        \}
    
        PImage in() \{
            PImage\[\] ins = \{ in0, in1, in2, in3, in4, in5, in6 \};
            if(LAST_INPUT.equals(inputsToCells)) \{
                return ins\[min(no, cellsInputs-1)\];
            \} else \{ // if CYCLE
                return ins\[no % cellsInputs\];
            \}
        \}
        
        PVector colour() \{
            return coloursRef.get().get(no);
        \}
    \}
    
    class RawGeometry \{
        final List<PVector> centres;
        final List<List<PVector>> polygons;

        public RawGeometry() \{
            centres = Collections.emptyList();
            polygons = Collections.emptyList();
        \}

        public RawGeometry(List<PVector> centres, List<List<PVector>> polygons) \{
            this.centres = centres;
            this.polygons = polygons;
        \}
    \}
"
      .cells-inputs 7
      .edge-width 5.335720890574503
      .draw-cells true
      .just-colours false
    }
    @ ./composite-0 video:composite {
      #%graph.x -674
      #%graph.y -191
    }
    @ ./colour-0 video:gl:p2d {
      #%graph.x -1011
      #%graph.y -167
      .code "import java.awt.Color;


    @P(0) @Type.Integer @OnChange(\"onIntRgb\") int intRgb;
    @P(1) @Type.String @OnChange(\"onHexRgb\") String hexRgb;
    @P(10) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double red;
    @P(11) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double green;
    @P(12) @Type.Number(min = 0, max = 255) @OnChange(\"onRgb\") double blue;
    @P(20) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double hue;
    @P(21) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double saturation;
    @P(22) @Type.Number(min = 0, max = 1) @OnChange(\"onHsv\") double brightness;

    @Override
    public void setup() \{
        noStroke();
    \}

    @Override
    public void draw() \{
        fill(red, green, blue);
        rect(0, 0, width, height);
    \}
    
    // Change handlers
    
    void onIntRgb() \{
        Color c = new Color(intRgb);
        red = c.getRed();
        green = c.getGreen();
        blue = c.getBlue();

        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHex() \{
        int h = hexRgb.startsWith(\"#\") ? 1 : 0;
        red = Integer.valueOf(hexRgb.substring(h + 0, h + 2), 16);
        green = Integer.valueOf(hexRgb.substring(h + 2, h + 4), 16);
        blue = Integer.valueOf(hexRgb.substring(h + 4, h + 6), 16);
        
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onRgb() \{
        setIntRgb();
        setHsv();
        setHex();
    \}

    void onHsv() \{
        Color rgb = Color.getHSBColor((float)hue, (float)saturation, (float)brightness);
        red = rgb.getRed();
        green = rgb.getGreen();
        blue = rgb.getBlue();
        
        setIntRgb();
        setHex();
    \}
    
    // Colour component setters

    void setIntRgb() \{
        intRgb = new Color((int)red, (int)green, (int)blue).getRGB();
    \}
    
    void setHex() \{
        hexRgb = String.format(\"%06X\", new Color((int)red, (int)green, (int)blue).getRGB() & 0xFFFFFF);
    \}
    
    void setHsv() \{
        float\[\] hsb = new float\[3\];
        hsb = Color.RGBtoHSB((int)red, (int)green, (int)blue, hsb);
        hue = hsb\[0\];
        saturation = hsb\[1\];
        brightness = hsb\[2\];
    \}
"
      .int-rgb -8125594
      .hex-rgb 840366
      .red 132.66891891891893
      .green 3.0
      .blue 102.0
      .hue 0.8720930218696594
      .saturation 0.9772727489471436
      .brightness 0.5176470875740051
    }
    @ ./control core:custom {
      #%graph.x -1544
      #%graph.y -84
      .code "import java.io.DataOutputStream;
import java.io.DataInputStream;
import java.io.IOException;


    final Movements MOVEMENTS = Movements.randomly;
    final double MOVEMENT_SPEED = 28;
    final double TIME_TO_MOVE = 0.2;
    final int MOVE_TO_CENTRE = 0;
    final int CELLS_COUNT = 9;
    final double TRANSITION_TIME = 10;


    void activate() \{
        newMovementSpeed.set(currentMovementSpeed).to(MOVEMENT_SPEED).in(TRANSITION_TIME);
        newTimeToMove.set(currentTimeToMove).to(TIME_TO_MOVE).in(TRANSITION_TIME);
        newCellsCount.set(currentCcellsCount).to(CELLS_COUNT).in(TRANSITION_TIME);
        transition.set(100).to(0).in(TRANSITION_TIME);
        xFade.send();
    \}
    
    @T(1)
    void experiment() \{
        activate();
    \}

    
////////////////////////////////////////////////////////
//// Common code below     
    
    //@P(0) @Transient @ReadOnly
    Movements currentMovements;
    //@P(1) @Transient @ReadOnly
    double currentMovementSpeed;
    //@P(2) @Transient @ReadOnly
    double currentTimeToMove;
    //@P(3) @Transient @ReadOnly
    int currentCcellsCount;
    //@P(4) @Transient @ReadOnly
    int currentMoveToCentre;

    @P(10) @ReadOnly @Transient
    Movements newMovements;
    @P(11) @ReadOnly @Transient @Type.Number
    Property newMovementSpeed;
    @P(12) @ReadOnly @Transient @Type.Number
    Property newTimeToMove;
    @P(13) @ReadOnly @Transient @Type.Integer
    Property newCellsCount;
    @P(14) @ReadOnly @Transient @Type.Integer
    Property newMoveToCentre;
    
    @P(20) @ReadOnly @Transient @Type.Number
    Property transition;
    
    @AuxOut(100) Output propertiesOut;
    @AuxIn(100) @ReadOnly Input propertiesIn;
    
    @AuxOut(200) Output xFade;
    
    
    @Override
    public void init() \{
        propertiesIn.valuesAs(PBytes.class).link(this::receiveProperties);
        newMovements = MOVEMENTS;
        newMovementSpeed.set(MOVEMENT_SPEED);
        newTimeToMove.set(TIME_TO_MOVE);
        newMoveToCentre.set(MOVE_TO_CENTRE);
        newCellsCount.set(CELLS_COUNT);
        transition.set(0);
    \}
    
    @Override
    public void update() \{
        if(transition.isAnimating()) \{
            if(d(transition) < TRANSITION_TIME/2) \{
                newMovements = MOVEMENTS;
                newMoveToCentre.set(MOVE_TO_CENTRE);
            \}
            send();
        \}
    \}
    
    void send() \{
        try (PBytes.OutputStream os = new PBytes.OutputStream()) \{
            DataOutputStream dos = new DataOutputStream(os);
            dos.writeInt(newMovements.ordinal());
            dos.writeDouble(d(newMovementSpeed));
            dos.writeDouble(d(newTimeToMove));
            dos.writeInt(i(newCellsCount));
            dos.writeInt(i(newMoveToCentre));
            PBytes bytes = os.toBytes();
            propertiesOut.send(bytes);
            dos.close();
        \} catch (Exception ex) \{
            log(ERROR, \"Properties encoding failure\");
            throw new RuntimeException(ex);
        \}
    \}

    void receiveProperties(PBytes bytes) \{
        DataInputStream dis = new DataInputStream(bytes.asInputStream());
        try \{
            if(dis.available() > 0) \{
                currentMovements = Movements.values()\[dis.readInt()\];
                currentMovementSpeed = dis.readDouble();
                currentTimeToMove = dis.readDouble();
                currentCcellsCount = dis.readInt();
                currentMoveToCentre = dis.readInt();
                dis.close();
            \}
        \} catch (IOException ex) \{
            log(ERROR, \"Properteies decoding failure\");
            throw new RuntimeException(ex);
        \}
    \}
    
    enum Movements \{
        all, oneByOne, randomly, unset
    \};
"
    }
    @ ./x-fader-send core:routing:send {
      #%graph.x -1259
      #%graph.y 141
      .address /video/x-fader.to-experiment
    }
    @ ./properties-out core:routing:send {
      #%graph.x -1258
      #%graph.y 43
      .address /video/voronoi-generator.properties-in
    }
    @ ./tunnel video:gl:p2d {
      #%graph.x -995
      #%graph.y -610
      .code "import java.awt.Color;


    @P(10)
    @Type.String(mime = GLSL_FRAGMENT_MIME)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;
    
    @Inject Property mx;
    @Inject Property my;
    
    @P(1) @Type.Number(min=0, max=2, def=0.4) double moveTime;
    @P(4) @Type.Number(skew = 4, min=0.1, max=100, def=1) double speed;
    
    PShader shader;
    
    void updateUniforms() \{
        shader.set(\"time\", millis()*speed/1000.1);
        shader.set(\"mouse\", d(mx), d(my));
        shader.set(\"resolution\", width, height);
    \}
    
    @T(1) void shakeIt() \{
        mx.to(random(0, width)).in(moveTime).easing(Easing.cubicInOut).whenDone(p1 -> \{
            mx.set(d(mx));
        \});
        my.to(random(0,height)).in(moveTime).easing(Easing.cubicInOut).whenDone(p1 -> \{
            my.set(d(my));
        \});
    \}

    @Override
    public void setup() \{
        updateShader();
        noStroke();
    \}
    
    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER, fragment);
        \}
        shader(shader);
        updateUniforms();
        rect(0, 0, width, height);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}
"
      .fragment "uniform vec2 resolution;
uniform float time;
uniform vec2 mouse;

// Protean clouds by nimitz (twitter: @stormoid)
// https://www.shadertoy.com/view/3l23Rh
// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
// Contact the author for other licensing options

/*
	Technical details:

	The main volume noise is generated from a deformed periodic grid, which can produce
	a large range of noise-like patterns at very cheap evalutation cost. Allowing for multiple
	fetches of volume gradient computation for improved lighting.

	To further accelerate marching, since the volume is smooth, more than half the the density
	information isn't used to rendering or shading but only as an underlying volume	distance to 
	determine dynamic step size, by carefully selecting an equation	(polynomial for speed) to 
	step as a function of overall density (not necessarialy rendered) the visual results can be 
	the	same as a naive implementation with ~40% increase in rendering performance.

	Since the dynamic marching step size is even less uniform due to steps not being rendered at all
	the fog is evaluated as the difference of the fog integral at each rendered step.

*/

mat2 rot(in float a)\{float c = cos(a), s = sin(a);return mat2(c,s,-s,c);\}
const mat3 m3 = mat3(0.33338, 0.56034, -0.71817, -0.87887, 0.32651, -0.15323, 0.15162, 0.69596, 0.61339)*1.93;
float mag2(vec2 p)\{return dot(p,p);\}
float linstep(in float mn, in float mx, in float x)\{ return clamp((x - mn)/(mx - mn), 0., 1.); \}
float prm1 = 0.;
vec2 bsMo = vec2(0);

vec2 disp(float t)\{ return vec2(sin(t*0.22)*1., cos(t*0.175)*1.)*2.; \}

vec2 map(vec3 p)
\{
    vec3 p2 = p;
    p2.xy -= disp(p.z).xy;
    p.xy *= rot(sin(p.z+time)*(0.1 + prm1*0.05) + time*0.09);
    float cl = mag2(p2.xy);
    float d = 0.;
    p *= .61;
    float z = 1.;
    float trk = 1.;
    float dspAmp = 0.1 + prm1*0.2;
    for(int i = 0; i < 5; i++)
    \{
		p += sin(p.zxy*0.75*trk + time*trk*.8)*dspAmp;
        d -= abs(dot(cos(p), sin(p.yzx))*z);
        z *= 0.57;
        trk *= 1.4;
        p = p*m3;
    \}
    d = abs(d + prm1*3.)+ prm1*.3 - 2.5 + bsMo.y;
    return vec2(d + cl*.2 + 0.25, cl);
\}

vec4 render( in vec3 ro, in vec3 rd, float time )
\{
	vec4 rez = vec4(0);
    const float ldst = 8.;
	vec3 lpos = vec3(disp(time + ldst)*0.5, time + ldst);
	float t = 1.5;
	float fogT = 0.;
	for(int i=0; i<130; i++)
	\{
		if(rez.a > 0.99)break;

		vec3 pos = ro + t*rd;
        vec2 mpv = map(pos);
		float den = clamp(mpv.x-0.3,0.,1.)*1.12;
		float dn = clamp((mpv.x + 2.),0.,3.);
        
		vec4 col = vec4(0);
        if (mpv.x > 0.6)
        \{
        
            col = vec4(sin(vec3(5.,0.4,0.2) + mpv.y*0.1 +sin(pos.z*0.4)*0.5 + 1.8)*0.5 + 0.5,0.08);
            col *= den*den*den;
			col.rgb *= linstep(4.,-2.5, mpv.x)*2.3;
            float dif =  clamp((den - map(pos+.8).x)/9., 0.001, 1. );
            dif += clamp((den - map(pos+.35).x)/2.5, 0.001, 1. );
            col.xyz *= den*(vec3(0.005,.045,.075) + 1.5*vec3(0.033,0.07,0.03)*dif);
        \}
		
		float fogC = exp(t*0.2 - 2.2);
		col.rgba += vec4(0.06,0.11,0.11, 0.1)*clamp(fogC-fogT, 0., 1.);
		fogT = fogC;
		rez = rez + col*(1. - rez.a);
		t += clamp(0.5 - dn*dn*.05, 0.09, 0.3);
	\}
	return clamp(rez, 0.0, 1.0);
\}

float getsat(vec3 c)
\{
    float mi = min(min(c.x, c.y), c.z);
    float ma = max(max(c.x, c.y), c.z);
    return (ma - mi)/(ma+ 1e-7);
\}

//from my \"Will it blend\" shader (https://www.shadertoy.com/view/lsdGzN)
vec3 iLerp(in vec3 a, in vec3 b, in float x)
\{
    vec3 ic = mix(a, b, x) + vec3(1e-6,0.,0.);
    float sd = abs(getsat(ic) - mix(getsat(a), getsat(b), x));
    vec3 dir = normalize(vec3(2.*ic.x - ic.y - ic.z, 2.*ic.y - ic.x - ic.z, 2.*ic.z - ic.y - ic.x));
    float lgt = dot(vec3(1.0), ic);
    float ff = dot(dir, normalize(ic));
    ic += 1.5*dir*sd*ff*lgt;
    return clamp(ic,0.,1.);
\}

void main()
\{	
	vec2 q = gl_FragCoord.xy/resolution.xy;
    vec2 p = (gl_FragCoord.xy - 0.5*resolution.xy)/resolution.y;
    
    bsMo = (mouse.xy - 0.5*resolution.xy)/resolution.y;
    
    float time = time*3.;
    vec3 ro = vec3(0,0,time);
    
    ro += vec3(sin(time)*0.5,sin(time*1.)*0.,0);
        
    float dspAmp = .85;
    ro.xy += disp(ro.z)*dspAmp;
    float tgtDst = 3.5;
    
    vec3 target = normalize(ro - vec3(disp(time + tgtDst)*dspAmp, time + tgtDst));
    ro.x -= bsMo.x*2.;
    vec3 rightdir = normalize(cross(target, vec3(0,1,0)));
    vec3 updir = normalize(cross(rightdir, target));
    rightdir = normalize(cross(updir, target));
	vec3 rd=normalize((p.x*rightdir + p.y*updir)*1. - target);
    rd.xy *= rot(-disp(time + 3.5).x*0.2 + bsMo.x);
    prm1 = smoothstep(-0.4, 0.4,sin(time*0.3));
	vec4 scn = render(ro, rd, time);
		
    vec3 col = scn.rgb;
    col = iLerp(col.bgr, col.rgb, clamp(1.-prm1,0.05,1.));
    
    col = pow(col, vec3(.55,0.65,0.6))*vec3(1.,.97,.9);

    col *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12)*0.7+0.3; //Vign
    
	gl_FragColor = vec4( col, 1.0 );
\}"
    }
    @ ./hsv video:gl:p2d {
      #%graph.x -819
      #%graph.y -57
      .code "

    @P(1) @Type.Number(min=0, max=360, def=0) double hue;
    @P(2) @Type.Number(min=0, max=2, def=1) double saturation;
    @P(3) @Type.Number(min=0, max=2, def=1) double value;
    
    void updateUniforms() \{
         shader.set(\"hue\", hue);
         shader.set(\"saturation\", saturation);
         shader.set(\"value\", value);
    \}

    
    // BOILERPLATE BELOW
    @In(0)
    PImage in;
    @P(0)
    @Type.String(mime = GLSL_FRAGMENT_MIME, template = DEFAULT_FRAGMENT_SHADER)
    @OnChange(\"updateShader\")
    @Config.Port(false)
    String fragment;

    PShader shader;

    @Override
    public void setup() \{
        updateShader();
    \}

    @Override
    public void draw() \{
        if (shader == null) \{
            shader = createShader(DEFAULT_VERTEX_SHADER,
                    fragment.isEmpty() ? DEFAULT_FRAGMENT_SHADER : fragment);
        \}
        shader(shader);
        updateUniforms();
        image(in, 0, 0);
        resetShader();
    \}

    void updateShader() \{
        shader = null;
    \}

"
      .fragment "// https://gamedev.stackexchange.com/a/59808
uniform sampler2D texture;

uniform vec2 texOffset;

uniform float hue;
uniform float saturation;
uniform float value;

varying vec4 vertColor;
varying vec4 vertTexCoord;

vec3 rgb2hsv(vec3 c) \{
    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));
    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));

    float d = q.x - min(q.w, q.y);
    float e = 1.0e-10;
    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);
\}

vec3 hsv2rgb(vec3 c) \{
    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);
    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);
\}

void main() \{
    vec4 textureColor = texture2D(texture, vertTexCoord.st) * vertColor;
    vec3 fragRGB = textureColor.rgb;
    vec3 fragHSV = rgb2hsv(fragRGB).xyz;
    fragHSV.x += hue / 360.0;
    fragHSV.y *= saturation;
    fragHSV.z *= value;
    fragRGB = hsv2rgb(fragHSV);
    gl_FragColor = vec4(fragRGB, textureColor.a);
\}"
      .hue 282.16216216216213
      .saturation 0.40540540540540543
      .value 0.7027027027027027
    }
    ~ ./ping-control!ping-1-yellow ./strobe-0!strobe
    ~ ./ping-control!ping-0-red ./strobe-1!strobe
    ~ ./ping-control!ping-2-cyan ./strobe-2!strobe
    ~ ./strobe-1!out ./voronoi-renderer1!in-0
    ~ ./strobe-0!out ./voronoi-renderer1!in-edges
    ~ ./strobe-2!out ./voronoi-renderer1!in-2
    ~ ./control!properties-out ./properties-out!in
    ~ ./control!x-fade ./x-fader-send!in
    ~ ./start-trigger-1!out ./tunnel!shake-it
    ~ ./tunnel!out ./voronoi-renderer1!in-0
    ~ ./tunnel!out ./voronoi-renderer1!in-1
    ~ ./tunnel!out ./voronoi-renderer1!in-2
    ~ ./tunnel!out ./composite-0!in
    ~ ./strobe-0!out ./voronoi-renderer1!in-4
    ~ ./ping-control!ping-1-yellow ./tunnel!shake-it
    ~ ./composite-0!out ./voronoi-renderer1!in-edges
    ~ ./tunnel!out ./voronoi-renderer1!in-3
    ~ ./tunnel!out ./voronoi-renderer1!in-4
    ~ ./composite-0!out ./voronoi-renderer1!in-6
    ~ ./composite-0!out ./voronoi-renderer1!in-5
    ~ ./tunnel!out ./hsv!in
    ~ ./hsv!out ./composite-0!src
  }
  ~ ./voronoi-generator!voronoi-out ./bw!in
  ~ ./voronoi-generator!properties-out ./bw-control!in
  ~ ./bw!out ./x-fader!bw
  ~ ./voronoi-generator!properties-out ./clouds-control!in
  ~ ./voronoi-generator!voronoi-out ./clouds!in
  ~ ./voronoi-generator!properties-out ./colours-control!in
  ~ ./voronoi-generator!voronoi-out ./colours!in
  ~ ./colours!out ./x-fader!colours
  ~ ./start!out ./voronoi-generator!move-cells
  ~ ./voronoi-generator!properties-out ./videos-control!in
  ~ ./voronoi-generator!voronoi-pipe-out ./city-buildings!voronoi-pipe-in
  ~ ./city-buildings!out ./x-fader!city-buildings
  ~ ./videos!out ./x-fader!videos
  ~ ./voronoi-generator!voronoi-pipe-out ./explosion!voronoi-pipe-in
  ~ ./explosion!out ./x-fader!explosion
  ~ ./voronoi-generator!voronoi-pipe-out ./videos!voronoi-pipe-in
  ~ ./clouds!out ./x-fader!clouds
  ~ ./voronoi-generator!voronoi-pipe-out ./bubbles!voronoi-pipe-in
  ~ ./bubbles!out ./x-fader!bubbles
  ~ ./x-fader!out ./composite-0!src
  ~ ./titles!out ./composite-0!in
  ~ ./composite-0!out ./screen!in
  ~ ./titles!mix ./composite-0!mix
  ~ ./logo-trigger!title ./titles!title
  ~ ./voronoi-generator!voronoi-pipe-out ./experiment!voronoi-pipe-in
  ~ ./experiment!out ./x-fader!experiment
  ~ ./ping-control!ping-0-red ./voronoi-generator!move-cells
  ~ ./x-fader!out ./screen!in
}
